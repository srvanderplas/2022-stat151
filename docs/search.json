[
  {
    "objectID": "index.html#how-to-use-this-book",
    "href": "index.html#how-to-use-this-book",
    "title": "Introduction to Statistical Computing",
    "section": "How to Use This Book",
    "text": "I’ve made an effort to use some specific formatting and enable certain features that make this book a useful tool for this class.\nSpecial Sections\nWatch Out\nWatch out sections contain things you may want to look out for - common errors, etc.\n \nExamples\nExample sections contain code and other information. Don’t skip them!\n \nMy Opinion\nThese sections contain things you should definitely not consider as fact and should just take with a grain of salt.\n \nGo Read\nSometimes, there are better resources out there than something I could write myself. When you see this section, go read the enclosed link as if it were part of the book.\n \nTry It Out\nTry it out sections contain activities you should do to reinforce the things you’ve just read.\n \nLearn More\nLearn More sections contain other references that may be useful on a specific topic. Suggestions are welcome (email me to suggest a new reference that I should add), as there’s no way for one person to catalog all of the helpful programming resources on the internet!\n \nNote\nNote sections contain clarification points (anywhere I would normally say “note that ….)\nExpandable Sections\nThese are expandable sections, with additional information when you click on the line\nThis additional information may be information that is helpful but not essential, or it may be that an example just takes a LOT of space and I want to make sure you can skim the book without having to scroll through a ton of output.\n \nMany times, examples will be in expandable sections\nThis keeps the code and output from obscuring the actual information in the textbook that I want you to retain. You can always look up the syntax, but you do need to absorb the details I’ve written out."
  },
  {
    "objectID": "index.html#about-this-book",
    "href": "index.html#about-this-book",
    "title": "Introduction to Statistical Computing",
    "section": "About This Book",
    "text": "This is a Quarto book. To learn more about Quarto books visit https://quarto.org/docs/books.\nI have written this entire book using reproducible techniques, with R and python code and results included within the book’s text.\nStat 151 will be offered for the first time in Spring 2022, as I’m writing this in Fall 2021. Initially, my goal is to write the book in R and include python as an additional option/example. Eventually, I hope to teach Stat 151 in R and Python at the same time."
  },
  {
    "objectID": "getting-started.html#getting-started-objectives",
    "href": "getting-started.html#getting-started-objectives",
    "title": "\n1  Getting Started\n",
    "section": "Objectives",
    "text": "Understand the basics of how computers work\nUnderstand the file system mental model for computers\nSet up RStudio, R, Quarto, and python\nBe able to run demo code in R and python"
  },
  {
    "objectID": "getting-started.html#computer-basics",
    "href": "getting-started.html#computer-basics",
    "title": "\n1  Getting Started\n",
    "section": "\n1.1 Computer Basics",
    "text": "It is helpful when teaching a topic as technical as programming to ensure that everyone starts from the same basic foundational understanding and mental model of how things work. When teaching geology, for instance, the instructor should probably make sure that everyone understands that the earth is a round ball and not a flat plate – it will save everyone some time later.\nWe all use computers daily - we carry them around with us on our wrists, in our pockets, and in our backpacks. This is no guarantee, however, that we understand how they work or what makes them go.\n\n1.1.1 Hardware\nHere is a short 3-minute video on the basic hardware that makes up your computer. It is focused on desktops, but the same components (with the exception of the optical drive) are commonly found in cell phones, smart watches, and laptops.\n\n\n\n\nWhen programming, it is usually helpful to understand the distinction between RAM and disk storage (hard drives). We also need to know at least a little bit about processors (so that we know when we’ve asked our processor to do too much). Most of the other details aren’t necessary (for now).\n\n\n\nChapter 1 of Python for Everybody - Computer hardware architecture\n\n\n\n1.1.2 Operating Systems\nOperating systems, such as Windows, MacOS, or Linux, are a sophisticated program that allows CPUs to keep track of multiple programs and tasks and execute them at the same time.\n\n\n\n\n\n1.1.3 File Systems\nEvidently, there has been a bit of generational shift as computers have evolved: the “file system” metaphor itself is outdated because no one uses physical files anymore. This article is an interesting discussion of the problem: it makes the argument that with modern search capabilities, most people use their computers as a laundry hamper instead of as a nice, organized filing cabinet.\nRegardless of how you tend to organize your personal files, it is probably helpful to understand the basics of what is meant by a computer file system – a way to organize data stored on a hard drive. Since data is always stored as 0’s and 1’s, it’s important to have some way to figure out what type of data is stored in a specific location, and how to interpret it.\n\n\n\n\nThat’s not enough, though - we also need to know how computers remember the location of what is stored where. Specifically, we need to understand file paths.\n\n\n\n\nWhen you write a program, you may have to reference external files - data stored in a .csv file, for instance, or a picture. Best practice is to create a file structure that contains everything you need to run your entire project in a single file folder (you can, and sometimes should, have sub-folders).\nFor now, it is enough to know how to find files using file paths, and how to refer to a file using a relative file path from your base folder. In this situation, your “base folder” is known as your working directory - the place your program thinks of as home."
  },
  {
    "objectID": "markdown.html#scripts",
    "href": "markdown.html#scripts",
    "title": "\n2  Scripts and Notebooks\n",
    "section": "\n2.1 Scripts",
    "text": "Before I show you how to use literate programming, let’s look at what it replaces: scripts. Scripts are files of code that are meant to be run on their own. They may produce results, or format data and save it somewhere, or scrape data from the web – scripts can do just about anything.\nScripts can even have documentation within the file, using # characters (at least, in R and python) at the beginning of a line. # indicates a comment – that is, that the line does not contain code and should be ignored by the computer when the program is run. Comments are incredibly useful to help humans understand what the code does and why it does it.\n\n2.1.1 Plotting a logarithmic spiral in R and python\nThis code will use concepts we have not yet introduced - feel free to tinker with it if you want, but know that you’re not responsible for being able to write this code yet. You just need to read it and get a sense for what it does. I have heavily commented it to help with this process.\n\n# Define the angle of the spiral (polar coords)\n# go around two full times (2*pi = one revolution)\ntheta <- seq(0, 4*pi, .01) \n# Define the distance from the origin of the spiral\n# Needs to have the same length as theta\nr <- seq(0, 5, length.out = length(theta))\n\n# Now define x and y in cartesian coordinates\nx <- r * cos(theta)\ny <- r * sin(theta)\n\nplot(x, y, type = \"l\")\n\n\n\nFigure 2.1: A Cartesian Spiral in R\n\n\n\n\nI have saved this script here. You can download it and open it up in RStudio (File -> Open -> Navigate to file location).\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the angle of the spiral (polar coords)\n# go around two full times (2*pi = one revolution)\ntheta = np.arange(0, 4 * np.pi, 0.01)\n# Define the distance from the origin of the spiral\n# Needs to have the same length as theta \n# (get length of theta with theta.size, \n#  and then divide 5 by that to get the increment)\nr = np.arange(0, 5, 5/theta.size)\n\n# Now define x and y in cartesian coordinates\nx = r * np.cos(theta)\ny = r * np.sin(theta)\n\n# Define the axes\nfig, ax = plt.subplots()\n# Plot the line\nax.plot(x, y)\nplt.show()\n\n\n\nFigure 2.2: A Cartesian Spiral in python\n\n\n\n\nI have saved this script here. You can download it and open it up in RStudio (File -> Open -> Navigate to file location).\nScripts can be run in Rstudio by clicking the Run button  at the top of the editor window when the script is open.\n\n2.1.2 Try it out!\n\nDownload the R and python scripts in the above example, open them in RStudio, and run each script using the Run button. What do you see?\n(Advanced) Open a terminal in RStudio (Tools -> Terminal -> New Terminal) and see if you can run the R script from the terminal using R CMD BATCH path/to/file/markdown-spiral-script.R (You will have to modify this command to point to the file on your machine)\nNotice that two new files appear in your working directory: Rplots.pdf and markdown-spiral-script.Rout\n(Advanced) Open a terminal in RStudio (Tools -> Terminal -> New Terminal) and see if you can run the R script from the terminal using python3 path/to/file/markdown-spiral-script.py (You will have to modify this command to point to the file on your machine)\nThis will require you to have python3 accessible to you on the command line, which may be a challenge if it is not set up in the way that I’m assuming it is. Feel free to make an appointment to see if we can figure it out, if this does not work the first time.\nMost of the time, you will run scripts interactively - that is, you’ll be sitting there watching the script run and seeing what the results are as you are modifying the script. However, one advantage to scripts over notebooks is that it is easy to write a script and schedule it to run without supervision to complete tasks which may be repetitive. I have a script that runs daily at midnight, 6am, noon, and 6pm to pull information off of the internet for a dataset I’m maintaining. I’ve set it up so that this all happens automatically and I only have to check the results when I am interested in working with that data."
  },
  {
    "objectID": "markdown.html#notebooks",
    "href": "markdown.html#notebooks",
    "title": "\n2  Scripts and Notebooks\n",
    "section": "\n2.2 Notebooks",
    "text": "Notebooks are an implementation of literate programming. Both R and python have native notebooks that are cross-platform and allow you to code in R or python. This book is written using Quarto markdown, which is an extension of Rmarkdown, but it is also possible to use jupyter notebooks to write R code.\nIn this class, we’re going to use Quarto/R markdown, because it is a much better tool for creating polished reports than Jupyter (in my opinion). This matters because the goal is that you learn something useful for your own coding and then you can easily apply it when you go to work as an analyst somewhere to produce impressive documents. Jupyter notebooks are great for interactive coding, but aren’t so wonderful for producing polished results. They also don’t allow you to switch between languages mid-notebook, and since I’m trying to teach this class in both R and python, I want you to have both languages available.\n\nThere are some excellent opinions surrounding the use of notebooks in data analysis:\n\n\nWhy I Don’t Like Notebooks” by Joel Grus at JupyterCon 2018\n\nThe First Notebook War by Yihui Xie (response to Joel’s talk).\nYihui Xie is the person responsible for knitr and Rmarkdown.\n\n\n \n\n2.2.1 Try it out - R markdown\nTake a look at the R markdown sample file I’ve created to go with the R script above. You can see the HTML file it generates here.\n\nDownload the Rmd file and open it with RStudio.\nChange the output to output: word_document and hit the Render button . Can you find the markdown-demo.docx file that was generated? What does it look like?\nChange the output to output: pdf_document and hit the Render button . Can you find the markdown-demo.pdf file that was generated? What does it look like?\n\nRmarkdown tries very hard to preserve your formatted text appropriately regardless of the output document type. While things may not look exactly the same, the goal is to allow you to focus on the content and the formatting will “just work”.\n \n\n2.2.2 Try it out - Jupyter\nTake a look at the jupyter notebook sample file I’ve created to go with the R script above. You can see the HTML file it generates here.\n\nDownload the ipynb file and open it with jupyter.\nExport the notebook as a pdf file (File -> Save as -> PDF via HTML). Can you find the jupyter-demo.pdf file that was generated? What does it look like?\nExport the notebook as an html file (File -> Save as -> HTML). Can you find the jupyter-demo.html file that was generated? What does it look like?\n \n\n2.2.3 Try it out - Quarto markdown\nThe nice thing about quarto is that it will work with python and R seamlessly, and you can compile the document using python or R. R markdown will also allow you to use python chunks, but you must compile the document in R.\nTake a look at the Qmd notebook sample file I’ve created to go with the scripts above. You’ll notice that it is basically the script portion of this textbook – that’s because I’m writing the textbook in Quarto.\n\nDownload the qmd file and open it with RStudio\nTry to compile the file by hitting the Render button \n(Advanced) In the terminal, type in quarto render path/to/file/quarto-demo.qmd. Does that render the HTML file?\nOne advantage of this is that using quarto to render the file doesn’t require R at the command line. As the document contains R chunks, R is still required to compile the document, but the biggest difference between qmd and rmd is that qmd files are workflow agnostic - you can generate them in e.g. MS Visual Studio Code, compile them in that workflow, and never have to use RStudio."
  },
  {
    "objectID": "finding-your-way.html#programming",
    "href": "finding-your-way.html#programming",
    "title": "\n3  Finding your way in R and Python\n",
    "section": "\n3.1 Programming",
    "text": "Programming today is a race between software engineers striving to build bigger and better idiot-proof programs, and the universe trying to produce bigger and better idiots. So far, the universe is winning. - Rick Cook\n\nProgramming is the art of solving a problem by developing a sequence of steps that make up a solution, and then very carefully communicating those steps to the computer. To program, you need to know how to\n\nbreak a problem down into smaller, easily solvable problems\nsolve small problems\ncommunicate the solution to a computer using a programming language\n\nIn this class, we’ll be using both R and Python, and we’ll be using these languages to solve problems that are related to working with data. At first, we’ll start with smaller, simpler problems that don’t involve data, but by the end of the semester, you will hopefully be able to solve some statistical problems using one or both languages.\nIt will be hard at first - you have to learn the vocabulary in both languages in order to be able to put commands into logical “sentences”. The problem solving skills are the same for all programming languages, though, and while those are harder to learn, they’ll last you a lifetime."
  },
  {
    "objectID": "finding-your-way.html#hello-world",
    "href": "finding-your-way.html#hello-world",
    "title": "\n3  Finding your way in R and Python\n",
    "section": "\n3.2 Hello world",
    "text": "I particularly like the way that Python for Everybody (Severance 2016) explains vocabulary:\n\nUnlike human languages, the Python vocabulary is actually pretty small. We call this “vocabulary” the “reserved words”. These are words that have very special meaning to Python. When Python sees these words in a Python program, they have one and only one meaning to Python. Later as you write programs you will make up your own words that have meaning to you called variables. You will have great latitude in choosing your names for your variables, but you cannot use any of Python’s reserved words as a name for a variable.\n\n\nWhen we train a dog, we use special words like “sit”, “stay”, and “fetch”. When you talk to a dog and don’t use any of the reserved words, they just look at you with a quizzical look on their face until you say a reserved word. For example, if you say, “I wish more people would walk to improve their overall health”, what most dogs likely hear is, “blah blah blah walk blah blah blah blah.” That is because “walk” is a reserved word in dog language. Many might suggest that the language between humans and cats has no reserved words.\n\n\nThe reserved words in the language where humans talk to Python include the following:\n\nand       del       global      not       with\nas        elif      if          or        yield\nassert    else      import      pass\nbreak     except    in          raise\nclass     finally   is          return\ncontinue  for       lambda      try\ndef       from      nonlocal    while    \n\nThat is it, and unlike a dog, Python is already completely trained. When you say ‘try’, Python will try every time you say it without fail.\n\n\nWe will learn these reserved words and how they are used in good time, but for now we will focus on the Python equivalent of “speak” (in human-to-dog language). The nice thing about telling Python to speak is that we can even tell it what to say by giving it a message in quotes:\n\n\nprint('Hello world!')\n\nHello world!\n\n\n\nAnd we have even written our first syntactically correct Python sentence. Our sentence starts with the function print followed by a string of text of our choosing enclosed in single quotes. The strings in the print statements are enclosed in quotes. Single quotes and double quotes do the same thing; most people use single quotes except in cases like this where a single quote (which is also an apostrophe) appears in the string.\n\nR has a slightly smaller set of reserved words:\nif          else     repeat      while        \nfor         in       next        break  \nTRUE        FALSE    NULL        Inf         \nNA_integer_ NA_real_ NA_complex_ NA_character_  \nNaN         NA       function    ...\nIn R, the “Hello World” program looks exactly the same as it does in python.\n\nprint('Hello world!')\n\n[1] \"Hello world!\"\n\n\nIn many situations, R and python will be similar because both languages are based on C. R has a more complicated history, because it is also similar to Lisp, but both languages are still very similar to C and run C or C++ code in the background."
  },
  {
    "objectID": "finding-your-way.html#talking-to-python-and-r---interactive-mode",
    "href": "finding-your-way.html#talking-to-python-and-r---interactive-mode",
    "title": "\n3  Finding your way in R and Python\n",
    "section": "\n3.3 Talking to Python and R - Interactive mode",
    "text": "R and python both have an “interactive mode” that you will use most often. In the previous chapter, we talked about scripts and markdown documents, both of which are non-interactive methods for writing R and python code. But for the moment, let’s work with the interactive console in both languages in order to get familiar with how we talk to R and python.\nLet’s start by creating a Qmd file (File -> New File -> Quarto Document) - this will let us work with R and python at the same time.\nAdd an R chunk to your file by typing ```{r} into the first line of the file, and then hit return. RStudio should add a blank line followed by ```.\nAdd a python chunk to your file by typing ```{python} on a blank line below the R chunk you just created, and then hit return. RStudio should add a blank line followed by ```.\nYour file should look like this:\n\n\nScreenshot of qmd file after adding an empty r and python chunk\n\n\nIf instead your file looks like this:\n\n\nScreenshot of qmd file with visual markdown editing on\n\n\nyou have visual markdown mode on. To turn it off, click on the A icon at the top right of your editor window:\n\n\nScreenshot of editor window toolbar, with A icon highlighted in green\n\n\nIf we are working in interactive mode, why did I have you start out by creating a markdown document? Good Question! RStudio allows you to switch back and forth between R and python seamlessly, which is good and bad - it’s hard to get a python terminal without telling R which language you’re working in! You can create a python script if you’d prefer to work in a script instead of a markdown document, but that would involve working in 2 separate files, which I personally find rather tedious.\n\n3.3.1 The R Console\nIn your R chunk or script, type in 2+2 and hit Ctrl+Enter (or Cmd+Enter on a mac). Look down to the Console (which is usually below the editor window) and see if 4 appears. If you’re like me, output shows up in two places at once:\n\n\nLocation\nPicture\n\n\n\nChunk\n\n\n\nScript\n\n\n\nConsole\n\n\n\n\nR will indicate that it is waiting for your command with a > character in the console. If you don’t see that > character, chances are you’ve forgotten to finish a statement - check for parentheses and brackets.\nWhen you are working in an R script, any output is shown only in the console. When you are working in an R code chunk, output is shown both below the chunk and in the console.\nIf you want, you can also just work within the R console. This can be useful for quick, interactive work, or if, like me, you’re too lazy to pull up a calculator on your machine and you just want to use R to calculate something quickly. You just type your R command into the console:\n\n\nR console with commands “Hello”, print(“Hello”), and (unquoted) “I love R”, which causes an error\n\n\nThe first two statements in the above example work - “Hello” is a string, and is thus a valid statement equivalent to typing “2” into the console and getting “2” back out. The second command, print(\"Hello\"), does the same thing - “Hello” is returned as the result. The third command, I love R, however, results in an error - there is an unexpected symbol (the space) in the statement. R thinks we are telling it to do something with variables I and love (which are not defined), and it doesn’t know what we want it to do to the two objects.\nSuppose we define I and love as variables by putting a value into each object using <-, which is the assignment operator. Then, typing “I love” into the console generates the same error, and R tells us “hey, there’s an unexpected symbol here” - in this case, maybe we meant to add the two variables together.\n\n\nR console with commands “Hello”, print(“Hello”), and (unquoted) “I love R”, which causes an error. Defining variables I and love provides us a context in which R’s error message about unexpected symbols makes sense - R is reminding us that we need a numerical operator in between the two variable names.\n\n\n\n3.3.2 The Python Console\nIn your python chunk or script, type in 2+2 and hit Ctrl+Enter (or Cmd+Enter on a mac). Look down to the Console (which is usually below the editor window) and see if 4 appears. If you’re like me, output shows up in two places at once:\n\n\nLocation\nPicture\n\n\n\nChunk\n\n\n\nScript\n\n\n\nConsole\n\n\n\n\nNotice that in the console, you get a bit of insight into how RStudio is running the python code: we see reticulate::repl_python(), which is R code telling R to run the line in Python. The python console has >>> instead of > to indicate that python is waiting for instructions.\nNotice also that the only difference between the R and python script file screenshots is that there is a different logo on the documents: . Personally, I think it’s easier to work in a markdown document and keep my notes with specific chunks labeled by language when I’m learning the two languages together, but when you are writing code for a specific project in a single language, it is probably better to use a script file specific to that language.\nIf you want to start the python console by itself (without a script or working in a markdown document), you can simply type reticulate::repl_python() into the R console. \nR is nice enough to remind you that to end the conversation with python, you just need to type “exit” or “quit”.\nIf you want to start a python console outside of RStudio, bring up your command prompt (Darwin on mac, Konsole on Linux, CMD on Windows) and type python3 into that window and you should see the familiar >>> waiting for a command."
  },
  {
    "objectID": "finding-your-way.html#talking-to-python-and-r---script-mode",
    "href": "finding-your-way.html#talking-to-python-and-r---script-mode",
    "title": "\n3  Finding your way in R and Python\n",
    "section": "\n3.4 Talking to Python and R - Script Mode",
    "text": "In the last chapter, we played around with scripts and markdown documents for python and R. In the last section, we played with interactive mode by typing R and python commands into a console or running code chunks interactively using the Run button or Ctrl/Cmd + Enter (which is the keyboard shortcut).\nYou may be learning to program in R and python because it’s a required part of the curriculum, but hopefully, you also have some broader ideas of what you might do with either language - process data, make pretty pictures, write a program to trigger the computer uprising…\nScripts are best used when you have a thing you want to do, and you will need to do that thing many times, perhaps with different input data. Suppose that I have a text file and I want to pull out the most common word in that file. In the next few examples, I will show you how to do this in R and python, and at the same time, demonstrate the difference between interactive mode and script mode in both languages. In each example, try to compare to the previous example to identify whether something is running as a full script or in interactive mode, and how it is launched (in R? at the command line?).\nSeverance (2016) provides a handy python program to count words. This program is meant to be run on the command line, and it will run for any specified text file.\n\n3.4.1 Example: Counting Words in Python on the Command Line\nDownload words.py to your computer and open up a command line terminal in the location where you saved the file.\nBefore you run the script, save Oliver Twist to the same folder as dickens-oliver-627.txt (you can use another file name, but you will have to adjust your response to the program)\n\nname = input('Enter file:')\nhandle = open(name, 'r')\ncounts = dict()\n\nfor line in handle:\n    words = line.split()\n    for word in words:\n        counts[word] = counts.get(word, 0) + 1\n\nbigcount = None\nbigword = None\nfor word, count in list(counts.items()):\n    if bigcount is None or count > bigcount:\n        bigword = word\n        bigcount = count\n\nprint(bigword, bigcount)\n\n# Code: http://www.py4e.com/code3/words.py\n\nIn your terminal, type in python words.py. If all goes well, you should get a prompt that tells you to enter a file name. Type in dickens-oliver-627.txt, and the program will read in the file and execute the program according to the instructions shown above. You don’t need to understand what is happening in this program (just like you don’t need to understand what is happening in the R code above either) – you get the answer anyways: the most common word, according to the output from the program, is\nthe 8854\nThat is, the word the occurs 8854 times in the text.\n\n\nScreenshot of folder and python script evaluation, showing how to run the python script in the terminal and get the count of the most common word, ‘the’, in the file dickens-oliver-627.txt\n\n\n \n\n3.4.2 Example: Counting Words in Python within RStudio\nWe can run this script in interactive mode in RStudio if we want to: Open the words.py file you downloaded in RStudio.\n\n\nRstudio screenshot showing the words.py file opened, with a green highlighted rectangle around the button “Source Script” which allows you to run the file in RStudio.\n\n\nClick the “Source Script” button highlighted in green above, and then look at the console below the script window:\n Once you enter the path to the text file – this time, from the project working directory – you get the same answer. It can be a bit tricky to figure out what your current working directory is in RStudio, but in the R console you can get that information with the getwd() command.\n\n\nRStudio screenshot of console window with getwd() command and result\n\n\nSince I know that I have stored the text file in the data subdirectory of the stat151book folder, I can type in data/dickens-oliver-627.txt and the python program can find my file.\n \nIn the above example, RStudio is functioning essentially like a terminal window - it runs the script as a single file, and once it has your input, all commands are executed one after the other automatically. This is convenient if you want to test the whole block of code at once, but it can be more useful to test each line individually and “play” with the output a bit (or modify code line-by-line).\n\n3.4.3 Example: Counting Words in Python in Interactive Mode (RStudio)\nSuppose we want to modify this python script to be more like the R script, where we tell python what the file name is in the file itself, instead of waiting for user input at the terminal.\nInstead of using the input command, I just provide python with a string that contains the path to the file. If you have downloaded the text file to a different folder and RStudio’s working directory is set to that folder, you would change the first line to name = \"dickens-oliver-627.txt\" - I have set things up to live in a data folder because if I had all of the files in the same directory where this book lives, I would never be able to find anything.\nCreate a new python script file in RStudio (File -> New File -> Python Script) and paste in the following lines of code, adjusting the path to the text file appropriately.\n\nname = \"data/dickens-oliver-627.txt\"\nhandle = open(name, 'r')\ncounts = dict()\n\nfor line in handle:\n    words = line.split()\n    for word in words:\n        counts[word] = counts.get(word, 0) + 1\n\nbigcount = None\nbigword = None\nfor word, count in list(counts.items()):\n    if bigcount is None or count > bigcount:\n        bigword = word\n        bigcount = count\n\nprint(bigword, bigcount)\n\n# Code: http://www.py4e.com/code3/words.py\n\nthe 8854\n\n\n\n\nAbove script in the RStudio text editor window, with the first 3 lines of code highlighted\n\n\nWith the first 3 lines highlighted, click the Run button.\n We can examine the objects that we have defined this far in the program by typing their names into the console directly.\n\n\nRStudio python console allows us to examine the objects we have defined after the first 3 lines of code have been run. We can see that counts is an empty object, handle is a pointer to a text file, and name is a string with the path to the text file – so far, so good.\n\n\nIf we want to continue walking through the program chunk by chunk, we can run the next four lines of code. Lines 5-8 are a for loop, so we should run them all at once unless we want to fiddle with how the for loop works.\n\n\nRStudio editor window with the next four lines of the code chunk highlighted. If we click the Run button, we can tell python to evaluate these few lines of code, and then we can see what the objects we’ve defined look like once that has been done\n\n\nSelect lines 5-8 as shown above, and click the Run button. Your console window should update with additional lines of code. You can type in counts after that has been evaluated to see what the counts object looks like now.\n\n\nRStudio python console with lines 5-8 run and the counts object displayed. Counts is now filled with words and corresponding integer counts of the frequency of that word’s appearance in the text\n\n\nThe next few lines of code determine which word has the highest count. We won’t get into the details here, but to finish out the running of the program, select lines 10-17 and run them in RStudio.\n\n\nRStudio editor window and console showing the results when lines 10-17 are evaluated. It is clear that line 17 results in the console output of the 8854\n\n\nRunning scripts in interactive mode or within RStudio is much more convenient if you are still working on the script - it allows you to debug the script line-by-line if necessary. Running a script at the terminal (like we did above) is sometimes more convenient if you have a pre-written script that you know already works. Both modes are useful, but for the time being you will probably be running scripts within your development environment (RStudio or VSCode or any other IDE you prefer) more often than at the command line.\n\n3.4.4 Example: Counting Words in R within RStudio\nJust for fun, let’s work with Oliver Twist, by Charles Dickens, which I have saved here.\n\n# Read in the file\ntext <- readLines(\"dickens-oliver-627.txt\")\n\n# Split the lines of text into separate words\ntext <- strsplit(text, \" \")\n\n# Simplify the list\ntext <- unlist(text)\n\n# Count up the number of occurrences of each word\nword_freq <- table(text)\n\n# Sort the table by decreasing frequency\nword_freq <- sort(word_freq, decreasing = T)\n\n# Show the counts for the most common 10 words\nword_freq[1:10]\n\nMake a new R script (File -> New File -> R script) and copy the above code into R, or download the file to your computer directly and open the downloaded file in RStudio.\nIn the R console, run the command getwd() to see where R is running from. This is your “working directory”.\n\n\nR editor window with relevant script, with R console shown below. My working directory is /home/susan/Projects/Class/unl-stat151/stat151book/demo; yours will be different.\n\n\nSave the copy of Oliver Twist to the file dickens-oliver-627.txt in the folder that getwd() spit out. You can test that you have done this correctly by typing list.files() into the R console window and hitting enter. It is very important that you know where on your computer R is looking for files - otherwise, you will constantly get “file not found” errors, and that will be very annoying.\n\n\nR editor window with relevant script, with R console shown below. dickens-oliver-627.txt is in the working directory, so we can proceed.\n\n\nUse the “Run” button to run the script and see what the output is. How many times does ‘the’ appear in the file?\n \n\n3.4.5 Example: Counting words in R in Interactive Mode\nUsing the file you created above, let’s examine what each line does in interactive mode.\n\n# Read in the file\ntext <- readLines(\"dickens-oliver-627.txt\")\n\nSelect the above line and click the “Run” button in RStudio. Once you’ve done that, type in text[1:5] in the R console to see the first 5 lines of the file.\n\n\nRStudio editor window with the first 2 lines of the words-noinput.R file selected. The screenshot also shows the console window after running the first 2 lines of the R file, with the text[1:5] command run interactively afterwards showing the first 5 lines of the text file we read in.\n\n\nRun the next line of code using the run button (or click on the line of code and hit Ctrl/Cmd + Enter).\n\n# Split the lines of text into separate words\ntext <- strsplit(text, \" \")\n\nType in text[[1]] to see what the text object looks like now.\n\ntext[[1]]\n\n [1] \"The\"       \"Project\"   \"Gutenberg\" \"Etext\"     \"of\"        \"Oliver\"   \n [7] \"Twist\"     \"by\"        \"Charles\"   \"Dickens\"  \n\n\n\n\nScreenshot of RStudio editor window with lines of code highlighted, plus RStudio console with the code as run and text[[1]] showing the first entry in the text object - a list of the separate words in the first line of the text file.\n\n\n\n# Simplify the list\ntext <- unlist(text)\ntext[[1]]\n\n[1] \"The\"\n\ntext[1:20]\n\n [1] \"The\"       \"Project\"   \"Gutenberg\" \"Etext\"     \"of\"        \"Oliver\"   \n [7] \"Twist\"     \"by\"        \"Charles\"   \"Dickens\"   \"#13\"       \"in\"       \n[13] \"our\"       \"series\"    \"by\"        \"Charles\"   \"Dickens\"   \"Copyright\"\n[19] \"laws\"      \"are\"      \n\n\nRunning unlist on text simplifies the object so that it is now a single vector of every word in the file, without regard for which line it appears on.\n\n# Count up the number of occurrences of each word\nword_freq <- table(text)\nword_freq[1:5]\n\ntext\n            _I_     --'    --by --kneel \n   4558       4       1       1       1 \n\n\nThe next line assembles a table of frequency counts in text. There are 4558 spaces, 4 occurrences of the string _I_, and so on.\n\n# Sort the table by decreasing frequency\nword_freq <- sort(word_freq, decreasing = T)\nword_freq[1:5]\n\ntext\n the  and        to   of \n8854 4902 4558 3767 3763 \n\n\nWe can then sort word_freq so that the most frequent words are listed first. The final line just prints out the first 10 words instead of the first 5.\n \n\n3.4.6 Example: Counting Words in R on the Command Line\nDownload the following file to your working directory: words.R, or paste the following code into a new R script and save it as words.R\n\n# Take arguments from the command line\nargs <- commandArgs(TRUE)\n\n# Read in the file\ntext <- readLines(args[1])\n\n# Split the lines of text into separate words\ntext <- strsplit(text, \" \")\n\n# Simplify the list\ntext <- unlist(text)\n\n# Count up the number of occurrences of each word\nword_freq <- table(text)\n\n# Sort the table by decreasing frequency\nword_freq <- sort(word_freq, decreasing = T)\n\n# Show the counts for the most common 10 words\nword_freq[1:10]\n\nIn a terminal window opened at the location you saved the file (and the corresponding text file), enter the following: Rscript words.R dickens-oliver-627.txt.\nHere, Rscript is the command that tells R to evaluate the file, words.R is the R code to run, and dickens-oliver-627.txt is an argument to your R script that tells R where to find the text file. This is similar to the python code, but instead, the user passes the file name in at the same time as the script instead of having to wait around a little bit.\n\n3.4.7 Comparing Python and R\nThis is one good example of the difference in culture between python and R: python is a general-purpose programming language, where R is a domain specific programming language. In both languages, I’ve shown you how I would run the script by default first - in python, I would use a pre-built script to run things, and in R I would open things up in RStudio and source the script rather than running R from the command line.\nThis is a bit of a cultural difference – because python is a general purpose programming language, it is easy to use for a wide variety of tasks, and is a common choice for creating scripts that are used on the command line. R is a domain-specific language, so it is extremely easy to use R for data analysis, but that tends to take place (in my experience) in an interactive or script-development setting using RStudio. It is less natural to me to write an R script that takes input from the user on the command line, even though obviously R is completely capable of doing that task. More commonly, I will write an R script for my own use, and thus there is no need to make it easy to use on the command line, because I can just change it in interactive mode. Python scripts, on the other hand, may be written for a novice to use at the command line with no idea of how to write or modify python code. This is a subtle difference, and may not make a huge impression on you now, but it is something to keep in mind as you learn to write code in each language – the culture around python and the culture around R are slightly different, and this affects how each language is used in practice."
  },
  {
    "objectID": "finding-your-way.html#getting-help",
    "href": "finding-your-way.html#getting-help",
    "title": "\n3  Finding your way in R and Python\n",
    "section": "\n3.5 Getting help",
    "text": "In both R and python, you can access help with a ? - the order is just slightly different.\nSuppose we want to get help on a for loop in either language.\nIn R, we can run this line of code to get help on for loops.\n\n?`for`\n\nBecause for is a reserved word in R, we have to use backticks (the key above the TAB key) to surround the word for so that R knows we’re talking about the function itself. Most other function help can be accessed using ?function_name.\nIn python, we use for? to access the same information.\n\nfor?\n\n(You will have to run this in interactive mode for it to work in either language)\nw3schools has an excellent python help page that may be useful as well - usually, these pages will have examples. A similar set of pages exists for R help on basic functions\n\n\n\nA nice explanation of the difference between an interpreter and a compiler. Both Python and R are interpreted languages that are compiled from lower-level languages like C.\n\n\n\n\n\n\nSeverance, Dr Charles Russell. 2016. Python for Everybody: Exploring Data in Python 3. Edited by Sue Blumenberg and Elliott Hauser. Ann Arbor, MI: CreateSpace Independent Publishing Platform. https://www.py4e.com/html3/."
  },
  {
    "objectID": "data-types.html#values-and-types",
    "href": "data-types.html#values-and-types",
    "title": "\n4  Basic Data Types\n",
    "section": "\n4.1 Values and Types",
    "text": "Let’s start this section with some basic vocabulary.\n\na value is a basic unit of stuff that a program works with, like 1, 2, \"Hello, World\", and so on.\nvalues have types - 2 is an integer, \"Hello, World\" is a string (it contains a “string” of letters). Strings are in quotation marks to let us know that they are not variable names.\n\nIn both R and python, there are some very basic data types:\n\nlogical or boolean - FALSE/TRUE or 0/1 values. Sometimes, boolean is shortened to bool\ninteger - whole numbers (positive or negative)\n\ndouble or float or numeric- decimal numbers.\n\n\nfloat is short for floating-point value.\n\ndouble is a floating-point value with more precision (“double precision”).1\n\nR uses the name numeric to indicate a decimal value, regardless of precision.\n\n\ncharacter or string - holds text, usually enclosed in quotes.\n\nIf you don’t know what type a value is, both R and python have functions to help you with that:\n\nclass(FALSE)\nclass(2L) # by default, R treats all numbers as numeric/decimal values. \n          # The L indicates that we're talking about an integer. \nclass(2)\nclass(\"Hello, programmer!\")\n\n[1] \"logical\"\n[1] \"integer\"\n[1] \"numeric\"\n[1] \"character\"\n\n\n\ntype(False)\ntype(2)\ntype(3.1415)\ntype(\"This is python code\")\n\n<class 'bool'>\n<class 'int'>\n<class 'float'>\n<class 'str'>\n\n\n\nIn R, boolean values are TRUE and FALSE, but in Python they are True and False. Capitalization matters a LOT.\nOther things matter too: if we try to write a million, we would write it 1000000 instead of 1,000,000 (in both languages). Commas are used for separating numbers, not for proper spacing and punctuation of numbers. This is a hard thing to get used to but very important – especially when we start reading in data."
  },
  {
    "objectID": "data-types.html#variables",
    "href": "data-types.html#variables",
    "title": "\n4  Basic Data Types\n",
    "section": "\n4.2 Variables",
    "text": "Programming languages use variables - names that refer to values. Think of a variable as a container that holds something - instead of referring to the value, you can refer to the container and you will get whatever is stored inside.\nWe assign variables values using the syntax object_name <- value (R) or object_name = value (python). You can read this as “object name gets value” in your head.\n\nmessage <- \"So long and thanks for all the fish\"\nyear <- 2025\nthe_answer <- 42L\nearth_demolished <- FALSE\n\n\nmessage = \"So long and thanks for all the fish\"\nyear = 2025\nthe_answer = 42\nearth_demolished = False\n\n\nNote that in R, we assign variables values using the <- operator, where in Python, we assign variables values using the = operator. Technically, = will work for assignment in both languages, but <- is more common than = in R by convention.\n\nWe can then use the variables - do numerical computations, evaluate whether a proposition is true or false, and even manipulate the content of strings, all by referencing the variable by name.\n\n4.2.1 Valid Names\n\nThere are only two hard things in Computer Science: cache invalidation and naming things.\n– Phil Karlton\n\nObject names must start with a letter and can only contain letters, numbers, _, and . in R. In Python, object names must start with a letter and can consist of letters, numbers, and _ (that is, . is not a valid character in a Python variable name). While it is technically fine to use uppercase variable names in Python, it’s recommended that you use lowercase names for variables (you’ll see why later).\nWhat happens if we try to create a variable name that isn’t valid?\n\n1st_thing <- \"check your variable names!\"\n\nError: <text>:1:2: unexpected symbol\n1: 1st_thing\n     ^\n\n\n\n1st_thing <- \"check your variable names!\"\n\nNote: Run the above chunk in your python window - the book won’t compile if I set it to evaluate 😢. It generates an error of SyntaxError: invalid syntax (<string>, line 1)\n\nsecond.thing <- \"this isn't valid\"\n\nError in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'second' is not defined\n\nDetailed traceback:\n  File \"<string>\", line 1, in <module>\n\n\nIn both languages, starting a variable name with a number will get you an error message that lets you know that something isn’t right - “unexpected symbol” in R and “invalid syntax” in python.\nIn python, trying to have a . in a variable name gets a more interesting error: “ is not defined”. This is because in python, some objects have components and methods that can be accessed with .. We’ll get into this more later, but there is a good reason for python’s restriction about not using . in variable names.\nNaming things is difficult! When you name variables, try to make the names descriptive - what does the variable hold? What are you going to do with it? The more (concise) information you can pack into your variable names, the more readable your code will be.\n\nWhy is naming things hard? - Blog post by Neil Kakkar\n\nThere are a few different conventions for naming things that may be useful:\n\n\nsome_people_use_snake_case, where words are separated by underscores\n\nsomePeopleUseCamelCase, where words are appended but anything after the first word is capitalized (leading to words with humps like a camel).\n\nsome.people.use.periods (in R, obviously this doesn’t work in python)\nA few people mix conventions with variables_thatLookLike.this and they are almost universally hated 🦹\n\nAs long as you pick ONE naming convention and don’t mix-and-match, you’ll be fine. It will be easier to remember what you named your variables (or at least guess) and you’ll have fewer moments where you have to go scrolling through your script file looking for a variable you named."
  },
  {
    "objectID": "vectors.html",
    "href": "vectors.html",
    "title": "5  Vectors, Arrays, Indexing, and Loops",
    "section": "",
    "text": "Vectors, Matrices, and Numpy arrays. Logical indexing. For loops.\n(probably 2 weeks of content)"
  },
  {
    "objectID": "data-structures.html",
    "href": "data-structures.html",
    "title": "6  Data Structures",
    "section": "",
    "text": "data frames in R and Pandas"
  },
  {
    "objectID": "reading-data.html",
    "href": "reading-data.html",
    "title": "7  Reading in Data",
    "section": "",
    "text": "External data files - csv, excel, etc."
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "Introduction to Statistical Computing",
    "section": "",
    "text": ""
  },
  {
    "objectID": "statistics.html",
    "href": "statistics.html",
    "title": "Introduction to Statistical Computing",
    "section": "",
    "text": ""
  },
  {
    "objectID": "ttests.html",
    "href": "ttests.html",
    "title": "Introduction to Statistical Computing",
    "section": "",
    "text": ""
  },
  {
    "objectID": "linear-modeling.html",
    "href": "linear-modeling.html",
    "title": "Introduction to Statistical Computing",
    "section": "",
    "text": ""
  },
  {
    "objectID": "git-github.html",
    "href": "git-github.html",
    "title": "Introduction to Statistical Computing",
    "section": "",
    "text": ""
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Severance, Dr Charles Russell. 2016. Python for Everybody: Exploring Data in Python 3. Edited by Sue Blumenberg and Elliott Hauser. Ann Arbor, MI: CreateSpace Independent Publishing Platform. https://www.py4e.com/html3/."
  },
  {
    "objectID": "data-types.html#type-conversions",
    "href": "data-types.html#type-conversions",
    "title": "\n4  Basic Data Types\n",
    "section": "\n4.3 Type Conversions",
    "text": "We talked about values and types above, but skipped over a few details because we didn’t know enough about variables. It’s now time to come back to those details.\nWhat happens when we have an integer and a numeric type and we add them together? Hopefully, you don’t have to think too hard about what the result of 2 + 3.5 is, but this is a bit more complicated for a computer for two reasons: storage, and arithmetic.\nIn days of yore, programmers had to deal with memory allocation - when declaring a variable, the programmer had to explicitly define what type the variable was. This tended to look something like the code chunk below:\nint a = 1\ndouble b = 3.14159\nTypically, an integer would take up 32 bits of memory, and a double would take up 64 bits, so doubles used 2x the memory that integers did. Both R and python are dynamically typed, which means you don’t have to deal with any of the trouble of declaring what your variables will hold - the computer automatically figures out how much memory to use when you run the code. So we can avoid the discussion of memory allocation and types because we’re using higher-level languages that handle that stuff for us2.\nBut the discussion of types isn’t something we can completely avoid, because we still have to figure out what to do when we do operations on things of two different types - even if memory isn’t a concern, we still have to figure out the arithmetic question.\nSo let’s see what happens with a couple of examples, just to get a feel for type conversion (aka type casting or type coercion), which is the process of changing an expression from one data type to another.\n\nmode(2L + 3.14159) # add 2 and pi\n\n[1] \"numeric\"\n\nmode(2L + TRUE) # add integer 2 and TRUE\n\n[1] \"numeric\"\n\nmode(TRUE + FALSE) # add TRUE and FALSE\n\n[1] \"numeric\"\n\n\nIn R, all of the examples above are ‘numeric’ - basically, a catch-all class for things that are in some way, shape, or form numbers. Integers and decimal numbers are both numeric, but so are logicals (because they can be represented as 0 or 1).\n\ntype(2 + 3.14159)\n\n<class 'float'>\n\ntype(2 + True)\n\n<class 'int'>\n\ntype(True + False)\n\n<class 'int'>\n\n\nIn python, by contrast, anything without a decimal point is converted into an integer.\nYou may be asking yourself at this point why this matters, and that’s a decent question. We will eventually be reading in data from spreadsheets and other similar tabular data, and types become very important at that point, because we’ll have to know how R and python both handle type conversions. In the meantime, do a bit of experimentation - what happens when you try to add a string and a number? Which types are automatically converted to other types?"
  }
]