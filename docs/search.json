[
  {
    "objectID": "index.html#how-to-use-this-book",
    "href": "index.html#how-to-use-this-book",
    "title": "Introduction to Statistical Computing",
    "section": "How to Use This Book",
    "text": "I’ve made an effort to use some specific formatting and enable certain features that make this book a useful tool for this class.\nSpecial Sections\nWatch Out\nWatch out sections contain things you may want to look out for - common errors, etc.\n \nExamples\nExample sections contain code and other information. Don’t skip them!\n \nMy Opinion\nThese sections contain things you should definitely not consider as fact and should just take with a grain of salt.\n \nGo Read\nSometimes, there are better resources out there than something I could write myself. When you see this section, go read the enclosed link as if it were part of the book.\n \nTry It Out\nTry it out sections contain activities you should do to reinforce the things you’ve just read.\n \nLearn More\nLearn More sections contain other references that may be useful on a specific topic. Suggestions are welcome (email me to suggest a new reference that I should add), as there’s no way for one person to catalog all of the helpful programming resources on the internet!\n \nNote\nNote sections contain clarification points (anywhere I would normally say “note that ….)\nExpandable Sections\n\nThese are expandable sections, with additional information when you click on the line\n\nThis additional information may be information that is helpful but not essential, or it may be that an example just takes a LOT of space and I want to make sure you can skim the book without having to scroll through a ton of output.\n \n\nMany times, examples will be in expandable sections\n\nThis keeps the code and output from obscuring the actual information in the textbook that I want you to retain. You can always look up the syntax, but you do need to absorb the details I’ve written out."
  },
  {
    "objectID": "index.html#about-this-book",
    "href": "index.html#about-this-book",
    "title": "Introduction to Statistical Computing",
    "section": "About This Book",
    "text": "This is a Quarto book. To learn more about Quarto books visit https://quarto.org/docs/books.\nI have written this entire book using reproducible techniques, with R and python code and results included within the book’s text.\nStat 151 will be offered for the first time in Spring 2022, as I’m writing this in Fall 2021. Initially, my goal is to write the book in R and include python as an additional option/example. Eventually, I hope to teach Stat 151 in R and Python at the same time."
  },
  {
    "objectID": "getting-started.html#getting-started-objectives",
    "href": "getting-started.html#getting-started-objectives",
    "title": "\n1  Getting Started\n",
    "section": "Objectives",
    "text": "Understand the basics of how computers work\nUnderstand the file system mental model for computers\nSet up RStudio, R, Quarto, and python\nBe able to run demo code in R and python"
  },
  {
    "objectID": "getting-started.html#computer-basics",
    "href": "getting-started.html#computer-basics",
    "title": "\n1  Getting Started\n",
    "section": "\n1.1 Computer Basics",
    "text": "It is helpful when teaching a topic as technical as programming to ensure that everyone starts from the same basic foundational understanding and mental model of how things work. When teaching geology, for instance, the instructor should probably make sure that everyone understands that the earth is a round ball and not a flat plate – it will save everyone some time later.\nWe all use computers daily - we carry them around with us on our wrists, in our pockets, and in our backpacks. This is no guarantee, however, that we understand how they work or what makes them go.\n\n1.1.1 Hardware\nHere is a short 3-minute video on the basic hardware that makes up your computer. It is focused on desktops, but the same components (with the exception of the optical drive) are commonly found in cell phones, smart watches, and laptops.\n\n\n\n\nWhen programming, it is usually helpful to understand the distinction between RAM and disk storage (hard drives). We also need to know at least a little bit about processors (so that we know when we’ve asked our processor to do too much). Most of the other details aren’t necessary (for now).\n\n\n\nChapter 1 of Python for Everybody - Computer hardware architecture\n\n\n\n1.1.2 Operating Systems\nOperating systems, such as Windows, MacOS, or Linux, are a sophisticated program that allows CPUs to keep track of multiple programs and tasks and execute them at the same time.\n\n\n\n\n\n1.1.3 File Systems\nEvidently, there has been a bit of generational shift as computers have evolved: the “file system” metaphor itself is outdated because no one uses physical files anymore. This article is an interesting discussion of the problem: it makes the argument that with modern search capabilities, most people use their computers as a laundry hamper instead of as a nice, organized filing cabinet.\nRegardless of how you tend to organize your personal files, it is probably helpful to understand the basics of what is meant by a computer file system – a way to organize data stored on a hard drive. Since data is always stored as 0’s and 1’s, it’s important to have some way to figure out what type of data is stored in a specific location, and how to interpret it.\n\n\n\n\nThat’s not enough, though - we also need to know how computers remember the location of what is stored where. Specifically, we need to understand file paths.\n\n\n\n\nWhen you write a program, you may have to reference external files - data stored in a .csv file, for instance, or a picture. Best practice is to create a file structure that contains everything you need to run your entire project in a single file folder (you can, and sometimes should, have sub-folders).\nFor now, it is enough to know how to find files using file paths, and how to refer to a file using a relative file path from your base folder. In this situation, your “base folder” is known as your working directory - the place your program thinks of as home."
  },
  {
    "objectID": "markdown.html#scripts",
    "href": "markdown.html#scripts",
    "title": "\n2  Scripts and Notebooks\n",
    "section": "\n2.1 Scripts",
    "text": "Before I show you how to use literate programming, let’s look at what it replaces: scripts. Scripts are files of code that are meant to be run on their own. They may produce results, or format data and save it somewhere, or scrape data from the web – scripts can do just about anything.\nScripts can even have documentation within the file, using # characters (at least, in R and python) at the beginning of a line. # indicates a comment – that is, that the line does not contain code and should be ignored by the computer when the program is run. Comments are incredibly useful to help humans understand what the code does and why it does it.\n\n2.1.1 Plotting a logarithmic spiral in R and python\nThis code will use concepts we have not yet introduced - feel free to tinker with it if you want, but know that you’re not responsible for being able to write this code yet. You just need to read it and get a sense for what it does. I have heavily commented it to help with this process.\n\n# Define the angle of the spiral (polar coords)\n# go around two full times (2*pi = one revolution)\ntheta <- seq(0, 4*pi, .01) \n# Define the distance from the origin of the spiral\n# Needs to have the same length as theta\nr <- seq(0, 5, length.out = length(theta))\n\n# Now define x and y in cartesian coordinates\nx <- r * cos(theta)\ny <- r * sin(theta)\n\nplot(x, y, type = \"l\")\n\n\n\nFigure 2.1: A Cartesian Spiral in R\n\n\n\n\nI have saved this script here. You can download it and open it up in RStudio (File -> Open -> Navigate to file location).\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the angle of the spiral (polar coords)\n# go around two full times (2*pi = one revolution)\ntheta = np.arange(0, 4 * np.pi, 0.01)\n# Define the distance from the origin of the spiral\n# Needs to have the same length as theta \n# (get length of theta with theta.size, \n#  and then divide 5 by that to get the increment)\nr = np.arange(0, 5, 5/theta.size)\n\n# Now define x and y in cartesian coordinates\nx = r * np.cos(theta)\ny = r * np.sin(theta)\n\n# Define the axes\nfig, ax = plt.subplots()\n# Plot the line\nax.plot(x, y)\nplt.show()\n\n\n\nFigure 2.2: A Cartesian Spiral in python\n\n\n\n\nI have saved this script here. You can download it and open it up in RStudio (File -> Open -> Navigate to file location).\nScripts can be run in Rstudio by clicking the Run button  at the top of the editor window when the script is open.\n\n2.1.2 Try it out!\n\nDownload the R and python scripts in the above example, open them in RStudio, and run each script using the Run button. What do you see?\n(Advanced) Open a terminal in RStudio (Tools -> Terminal -> New Terminal) and see if you can run the R script from the terminal using R CMD BATCH path/to/file/markdown-spiral-script.R (You will have to modify this command to point to the file on your machine)\nNotice that two new files appear in your working directory: Rplots.pdf and markdown-spiral-script.Rout\n(Advanced) Open a terminal in RStudio (Tools -> Terminal -> New Terminal) and see if you can run the R script from the terminal using python3 path/to/file/markdown-spiral-script.py (You will have to modify this command to point to the file on your machine)\nThis will require you to have python3 accessible to you on the command line, which may be a challenge if it is not set up in the way that I’m assuming it is. Feel free to make an appointment to see if we can figure it out, if this does not work the first time.\nMost of the time, you will run scripts interactively - that is, you’ll be sitting there watching the script run and seeing what the results are as you are modifying the script. However, one advantage to scripts over notebooks is that it is easy to write a script and schedule it to run without supervision to complete tasks which may be repetitive. I have a script that runs daily at midnight, 6am, noon, and 6pm to pull information off of the internet for a dataset I’m maintaining. I’ve set it up so that this all happens automatically and I only have to check the results when I am interested in working with that data."
  },
  {
    "objectID": "markdown.html#notebooks",
    "href": "markdown.html#notebooks",
    "title": "\n2  Scripts and Notebooks\n",
    "section": "\n2.2 Notebooks",
    "text": "Notebooks are an implementation of literate programming. Both R and python have native notebooks that are cross-platform and allow you to code in R or python. This book is written using Quarto markdown, which is an extension of Rmarkdown, but it is also possible to use jupyter notebooks to write R code.\nIn this class, we’re going to use Quarto/R markdown, because it is a much better tool for creating polished reports than Jupyter (in my opinion). This matters because the goal is that you learn something useful for your own coding and then you can easily apply it when you go to work as an analyst somewhere to produce impressive documents. Jupyter notebooks are great for interactive coding, but aren’t so wonderful for producing polished results. They also don’t allow you to switch between languages mid-notebook, and since I’m trying to teach this class in both R and python, I want you to have both languages available.\n\nThere are some excellent opinions surrounding the use of notebooks in data analysis:\n\n\nWhy I Don’t Like Notebooks” by Joel Grus at JupyterCon 2018\n\nThe First Notebook War by Yihui Xie (response to Joel’s talk).\nYihui Xie is the person responsible for knitr and Rmarkdown.\n\n\n \n\n2.2.1 Try it out - R markdown\nTake a look at the R markdown sample file I’ve created to go with the R script above. You can see the HTML file it generates here.\n\nDownload the Rmd file and open it with RStudio.\nChange the output to output: word_document and hit the Render button . Can you find the markdown-demo.docx file that was generated? What does it look like?\nChange the output to output: pdf_document and hit the Render button . Can you find the markdown-demo.pdf file that was generated? What does it look like?\n\nRmarkdown tries very hard to preserve your formatted text appropriately regardless of the output document type. While things may not look exactly the same, the goal is to allow you to focus on the content and the formatting will “just work”.\n \n\n2.2.2 Try it out - Jupyter\nTake a look at the jupyter notebook sample file I’ve created to go with the R script above. You can see the HTML file it generates here.\n\nDownload the ipynb file and open it with jupyter.\nExport the notebook as a pdf file (File -> Save as -> PDF via HTML). Can you find the jupyter-demo.pdf file that was generated? What does it look like?\nExport the notebook as an html file (File -> Save as -> HTML). Can you find the jupyter-demo.html file that was generated? What does it look like?\n \n\n2.2.3 Try it out - Quarto markdown\nThe nice thing about quarto is that it will work with python and R seamlessly, and you can compile the document using python or R. R markdown will also allow you to use python chunks, but you must compile the document in R.\nTake a look at the Qmd notebook sample file I’ve created to go with the scripts above. You’ll notice that it is basically the script portion of this textbook – that’s because I’m writing the textbook in Quarto.\n\nDownload the qmd file and open it with RStudio\nTry to compile the file by hitting the Render button \n(Advanced) In the terminal, type in quarto render path/to/file/quarto-demo.qmd. Does that render the HTML file?\nOne advantage of this is that using quarto to render the file doesn’t require R at the command line. As the document contains R chunks, R is still required to compile the document, but the biggest difference between qmd and rmd is that qmd files are workflow agnostic - you can generate them in e.g. MS Visual Studio Code, compile them in that workflow, and never have to use RStudio."
  },
  {
    "objectID": "finding-your-way.html#programming",
    "href": "finding-your-way.html#programming",
    "title": "\n3  Finding your way in R and Python\n",
    "section": "\n3.1 Programming",
    "text": "Programming today is a race between software engineers striving to build bigger and better idiot-proof programs, and the universe trying to produce bigger and better idiots. So far, the universe is winning. - Rick Cook\n\nProgramming is the art of solving a problem by developing a sequence of steps that make up a solution, and then very carefully communicating those steps to the computer. To program, you need to know how to\n\nbreak a problem down into smaller, easily solvable problems\nsolve small problems\ncommunicate the solution to a computer using a programming language\n\nIn this class, we’ll be using both R and Python, and we’ll be using these languages to solve problems that are related to working with data. At first, we’ll start with smaller, simpler problems that don’t involve data, but by the end of the semester, you will hopefully be able to solve some statistical problems using one or both languages.\nIt will be hard at first - you have to learn the vocabulary in both languages in order to be able to put commands into logical “sentences”. The problem solving skills are the same for all programming languages, though, and while those are harder to learn, they’ll last you a lifetime."
  },
  {
    "objectID": "finding-your-way.html#hello-world",
    "href": "finding-your-way.html#hello-world",
    "title": "\n3  Finding your way in R and Python\n",
    "section": "\n3.2 Hello world",
    "text": "I particularly like the way that Python for Everybody (Severance 2016) explains vocabulary:\n\nUnlike human languages, the Python vocabulary is actually pretty small. We call this “vocabulary” the “reserved words”. These are words that have very special meaning to Python. When Python sees these words in a Python program, they have one and only one meaning to Python. Later as you write programs you will make up your own words that have meaning to you called variables. You will have great latitude in choosing your names for your variables, but you cannot use any of Python’s reserved words as a name for a variable.\n\n\nWhen we train a dog, we use special words like “sit”, “stay”, and “fetch”. When you talk to a dog and don’t use any of the reserved words, they just look at you with a quizzical look on their face until you say a reserved word. For example, if you say, “I wish more people would walk to improve their overall health”, what most dogs likely hear is, “blah blah blah walk blah blah blah blah.” That is because “walk” is a reserved word in dog language. Many might suggest that the language between humans and cats has no reserved words.\n\n\nThe reserved words in the language where humans talk to Python include the following:\n\nand       del       global      not       with\nas        elif      if          or        yield\nassert    else      import      pass\nbreak     except    in          raise\nclass     finally   is          return\ncontinue  for       lambda      try\ndef       from      nonlocal    while    \n\nThat is it, and unlike a dog, Python is already completely trained. When you say ‘try’, Python will try every time you say it without fail.\n\n\nWe will learn these reserved words and how they are used in good time, but for now we will focus on the Python equivalent of “speak” (in human-to-dog language). The nice thing about telling Python to speak is that we can even tell it what to say by giving it a message in quotes:\n\n\nprint('Hello world!')\n\nHello world!\n\n\n\nAnd we have even written our first syntactically correct Python sentence. Our sentence starts with the function print followed by a string of text of our choosing enclosed in single quotes. The strings in the print statements are enclosed in quotes. Single quotes and double quotes do the same thing; most people use single quotes except in cases like this where a single quote (which is also an apostrophe) appears in the string.\n\nR has a slightly smaller set of reserved words:\nif          else     repeat      while        \nfor         in       next        break  \nTRUE        FALSE    NULL        Inf         \nNA_integer_ NA_real_ NA_complex_ NA_character_  \nNaN         NA       function    ...\nIn R, the “Hello World” program looks exactly the same as it does in python.\n\nprint('Hello world!')\n\n[1] \"Hello world!\"\n\n\nIn many situations, R and python will be similar because both languages are based on C. R has a more complicated history, because it is also similar to Lisp, but both languages are still very similar to C and run C or C++ code in the background."
  },
  {
    "objectID": "finding-your-way.html#talking-to-python-and-r---interactive-mode",
    "href": "finding-your-way.html#talking-to-python-and-r---interactive-mode",
    "title": "\n3  Finding your way in R and Python\n",
    "section": "\n3.3 Talking to Python and R - Interactive mode",
    "text": "R and python both have an “interactive mode” that you will use most often. In the previous chapter, we talked about scripts and markdown documents, both of which are non-interactive methods for writing R and python code. But for the moment, let’s work with the interactive console in both languages in order to get familiar with how we talk to R and python.\nLet’s start by creating a Qmd file (File -> New File -> Quarto Document) - this will let us work with R and python at the same time.\nAdd an R chunk to your file by typing ```{r} into the first line of the file, and then hit return. RStudio should add a blank line followed by ```.\nAdd a python chunk to your file by typing ```{python} on a blank line below the R chunk you just created, and then hit return. RStudio should add a blank line followed by ```.\nYour file should look like this:\n\n\nScreenshot of qmd file after adding an empty r and python chunk\n\n\nIf instead your file looks like this:\n\n\nScreenshot of qmd file with visual markdown editing on\n\n\nyou have visual markdown mode on. To turn it off, click on the A icon at the top right of your editor window:\n\n\nScreenshot of editor window toolbar, with A icon highlighted in green\n\n\nIf we are working in interactive mode, why did I have you start out by creating a markdown document? Good Question! RStudio allows you to switch back and forth between R and python seamlessly, which is good and bad - it’s hard to get a python terminal without telling R which language you’re working in! You can create a python script if you’d prefer to work in a script instead of a markdown document, but that would involve working in 2 separate files, which I personally find rather tedious.\n\n3.3.1 The R Console\nIn your R chunk or script, type in 2+2 and hit Ctrl+Enter (or Cmd+Enter on a mac). Look down to the Console (which is usually below the editor window) and see if 4 appears. If you’re like me, output shows up in two places at once:\n\n\nLocation\nPicture\n\n\n\nChunk\n\n\n\nScript\n\n\n\nConsole\n\n\n\n\nR will indicate that it is waiting for your command with a > character in the console. If you don’t see that > character, chances are you’ve forgotten to finish a statement - check for parentheses and brackets.\nWhen you are working in an R script, any output is shown only in the console. When you are working in an R code chunk, output is shown both below the chunk and in the console.\nIf you want, you can also just work within the R console. This can be useful for quick, interactive work, or if, like me, you’re too lazy to pull up a calculator on your machine and you just want to use R to calculate something quickly. You just type your R command into the console:\n\n\nR console with commands “Hello”, print(“Hello”), and (unquoted) “I love R”, which causes an error\n\n\nThe first two statements in the above example work - “Hello” is a string, and is thus a valid statement equivalent to typing “2” into the console and getting “2” back out. The second command, print(\"Hello\"), does the same thing - “Hello” is returned as the result. The third command, I love R, however, results in an error - there is an unexpected symbol (the space) in the statement. R thinks we are telling it to do something with variables I and love (which are not defined), and it doesn’t know what we want it to do to the two objects.\nSuppose we define I and love as variables by putting a value into each object using <-, which is the assignment operator. Then, typing “I love” into the console generates the same error, and R tells us “hey, there’s an unexpected symbol here” - in this case, maybe we meant to add the two variables together.\n\n\nR console with commands “Hello”, print(“Hello”), and (unquoted) “I love R”, which causes an error. Defining variables I and love provides us a context in which R’s error message about unexpected symbols makes sense - R is reminding us that we need a numerical operator in between the two variable names.\n\n\n\n3.3.2 The Python Console\nIn your python chunk or script, type in 2+2 and hit Ctrl+Enter (or Cmd+Enter on a mac). Look down to the Console (which is usually below the editor window) and see if 4 appears. If you’re like me, output shows up in two places at once:\n\n\nLocation\nPicture\n\n\n\nChunk\n\n\n\nScript\n\n\n\nConsole\n\n\n\n\nNotice that in the console, you get a bit of insight into how RStudio is running the python code: we see reticulate::repl_python(), which is R code telling R to run the line in Python. The python console has >>> instead of > to indicate that python is waiting for instructions.\nNotice also that the only difference between the R and python script file screenshots is that there is a different logo on the documents: . Personally, I think it’s easier to work in a markdown document and keep my notes with specific chunks labeled by language when I’m learning the two languages together, but when you are writing code for a specific project in a single language, it is probably better to use a script file specific to that language.\nIf you want to start the python console by itself (without a script or working in a markdown document), you can simply type reticulate::repl_python() into the R console. \nR is nice enough to remind you that to end the conversation with python, you just need to type “exit” or “quit”.\nIf you want to start a python console outside of RStudio, bring up your command prompt (Darwin on mac, Konsole on Linux, CMD on Windows) and type python3 into that window and you should see the familiar >>> waiting for a command."
  },
  {
    "objectID": "finding-your-way.html#talking-to-python-and-r---script-mode",
    "href": "finding-your-way.html#talking-to-python-and-r---script-mode",
    "title": "\n3  Finding your way in R and Python\n",
    "section": "\n3.4 Talking to Python and R - Script Mode",
    "text": "In the last chapter, we played around with scripts and markdown documents for python and R. In the last section, we played with interactive mode by typing R and python commands into a console or running code chunks interactively using the Run button or Ctrl/Cmd + Enter (which is the keyboard shortcut).\nXXX TODO: Explain the difference between scripts and interactive mode, running scripts in batch mode, etc. XXX\nYou may be learning to program in R and python because it’s a required part of the curriculum, but hopefully, you also have some broader ideas of what you might do with either language - process data, make pretty pictures, write a program to trigger the computer uprising…\nScripts are best used when you have a thing you want to do, and you will need to do that thing many times, perhaps with different input data. Suppose that I have a text file and I want to pull out the most common word in that file.\n\n3.4.1 Example: Counting Words in R\nJust for fun, let’s work with Oliver Twist, by Charles Dickens, which I have saved here.\n\n# Read in the file\ntext <- readLines(\"data/dickens-oliver-627.txt\")\n\n# Skip the first 252 lines, which are project gutenberg text\ntext <- text[-c(1:252)]\n\n# Remove punctuation\ntext <- gsub(\"[[:punct:]]\", \" \", text)\n\n# Convert to lower case\ntext <- tolower(text)\n\n# Split the lines of text into separate words\ntext <- strsplit(text, \" \")\n\n# Simplify the list\ntext <- unlist(text)\n\n# Count up the number of occurrences of each word\nword_freq <- sort(table(text), decreasing = T)\n\n# Show the counts for the most common 10 words\nword_freq[1:10]\n\ntext\n        the   and    to    of     a    he    in   his  that \n38656  9594  5393  3944  3843  3752  2496  2374  2341  1953"
  },
  {
    "objectID": "finding-your-way.html#getting-help",
    "href": "finding-your-way.html#getting-help",
    "title": "\n3  Finding your way in R and Python\n",
    "section": "\n3.5 Getting help",
    "text": "A nice explanation of the difference between an interpreter and a compiler. Both Python and R are interpreted languages that are compiled from lower-level languages like C.\n\n\n\n\n\n\nSeverance, Dr Charles Russell. 2016. Python for Everybody: Exploring Data in Python 3. Edited by Sue Blumenberg and Elliott Hauser. Ann Arbor, MI: CreateSpace Independent Publishing Platform. https://www.py4e.com/html3/."
  }
]