---
execute:
  freeze: auto  # re-render only when source changes
---

# Vectors, Matrices, Arrays, and Control Structures

<!-- Vectors, Matrices, and Numpy arrays. Logical indexing. For loops. -->

<!-- (probably 2 weeks of content) -->

<!-- Lego pictures made with https://www.mecabricks.com/en/workshop -->

This chapter introduces some of the most important tools for working with data: vectors, matrices, loops, and if statements. It would be nice to gradually introduce each one of these topics separately, but they tend to go together, especially when you're talking about programming in the context of data processing.

## Mathematical Logic

Before we start talking about data structures and control structures, though, we're going to take a minute to review some concepts from mathematical logic. This will be useful for both data structures and control structures, so stick with me for a few minutes.

### And, Or, and Not

We can combine logical statements using and, or, and not.

-   (X AND Y) requires that both X and Y are true.
-   (X OR Y) requires that one of X or Y is true.
-   (NOT X) is true if X is false, and false if X is true. Sometimes called **negation**.

In R, we use `!` to symbolize NOT, in Python, we use `~` for vector-wise negation (NOT).

Order of operations dictates that NOT is applied before other operations. So `NOT X AND Y` is read as `(NOT X) AND (Y)`. You must use parentheses to change the way this is interpreted.


::: panel-tabset

#### R

```{r}
x <- c(TRUE, FALSE, TRUE, FALSE)
y <- c(TRUE, TRUE, FALSE, FALSE)

x & y # AND
x | y # OR
!x & y # NOT X AND Y
x & !y # X AND NOT Y
```

#### Python

```{python}
import numpy as np
x = np.array([True, False, True, False])
y = np.array([True, True, False, False])

x & y
x | y
~x & y
x & ~y
```

:::

### De Morgan's Laws

[De Morgan's Laws](https://en.wikipedia.org/wiki/De_Morgan%27s_laws) are a set of rules for how to combine logical statements. You can represent them in a number of ways:

-   NOT(A or B) is equivalent to NOT(A) and NOT(B)
-   NOT(A and B) is equivalent to NOT(A) or NOT(B)

::: panel-tabset

We can also represent them with Venn Diagrams.

#### Definitions

![Venn Diagram of Set A and Set B](images/SetA%20and%20SetB.png) Suppose that we set the convention that ![Shaded regions are TRUE, unshaded regions are FALSE](images/TrueFalse.png).


#### DeMorgan's First Law

![A venn diagram illustration of De Morgan's laws showing that the region that is outside of the union of A OR B (aka NOT (A OR B)) is the same as the region that is outside of (NOT A) and (NOT B)](images/DeMorgan1.png)

#### DeMorgan's Second Law

![A venn diagram illustration of De Morgan's laws showing that the region that is outside of the union of A AND B (aka NOT (A AND B)) is the same as the region that is outside of (NOT A) OR (NOT B)](images/DeMorgan2.png)

:::

## Data Structures

In the previous chapter, we discussed 4 different data types: strings/characters, numeric/double/floats, integers, and logical/booleans. As you might imagine, things are about to get more complicated.

Data **structures** are more complicated arrangements of information.

| Homogeneous | Heterogeneous |            |
|-------------|---------------|------------|
| 1D          | vector        | list       |
| 2D          | matrix        | data frame |
| N-D         | array         |            |

### Lists

A **list** is a one-dimensional column of heterogeneous data - the things stored in a list can be of different types.

![A lego list: the bricks are all different types and colors, but they are still part of the same data structure.](images/lego-list.png)


::: panel-tabset

#### R {-}

```{r list-r}
x <- list("a", 3, FALSE)
x
```

#### Python {-}

```{python list-py}
x = ["a", 3, False]
x
```

:::

The most important thing to know about lists, for the moment, is how to pull things out of the list. We call that process **indexing**.


#### Indexing

Every element in a list has an **index** (a location, indicated by an integer position)[^vectors-1].

[^vectors-1]: Throughout this section (and other sections), lego pictures are rendered using https://www.mecabricks.com/en/workshop. It's a pretty nice tool for building stuff online!

::: panel-tabset

##### R concept {-}

In R, we count from 1. 

![An R-indexed lego list, counting from 1 to 5](images/list-indexing-r.png)

##### R code {-}

```{r, error = T}
x <- list("a", 3, FALSE)

x[1] # This returns a list
x[1:2] # This returns multiple elements in the list

x[[1]] # This returns the item
x[[1:2]] # This doesn't work - you can only use [[]] with a single index
```

In R, list indexing with `[]` will return a list with the specified elements.

To actually retrieve the item in the list, use `[[]]`. The only downside to `[[]]` is that you can only access one thing at a time.


##### Python concept {-}

In Python, we count from 0.

![A python-indexed lego list, counting from 0 to 4](images/list-indexing-py.png)

##### Python code {-}

```{python}
x = ["a", 3, False]

x[0]
x[1]
x[0:2]
```

In Python, we can use single brackets to get an object or a list back out, but we have to know how **slices** work. Essentially, in Python, `0:2` indicates that we want objects 0 and 1, but want to stop at 2 (not including 2). If you use a slice, Python will return a list; if you use a single index, python just returns the value in that location in the list.

:::

We'll talk more about indexing as it relates to vectors, but indexing is a general concept that applies to just about any multi-value object.


### Vectors

A **vector** is a one-dimensional column of homogeneous data. Homogeneous means that every element in a vector has the same data type.

We can have vectors of any data type and length we want: ![vectors of different data types](images/lego-set-of-vectors.png)

<!-- ![vector of purple 1x3 legos](images/lego-1x3-vector.png) -->

#### Indexing by Location

Each element in a vector has an **index** - an integer telling you what the item's position within the vector is. I'm going to demonstrate indices with the string vector

| R                                                                         | Python                                                                              |
|----------------------------------|--------------------------------------|
| 1-indexed language                                                        | 0-indexed language                                                                  |
| Count elements as 1, 2, 3, 4, ..., N                                      | Count elements as 0, 1, 2, 3, , ..., N-1                                            |
| ![R lego vector, labeled with numbers 1-12](images/lego-1x3-vector-R.png) | ![Python lego vector, labeled with numbers 0-11](images/lego-1x3-vector-python.png) |

::: panel-tabset

##### R {-}

In R, we create vectors with the `c()` function, which stands for "concatenate" - basically, we stick a bunch of objects into a row.

```{r vector-creation-r}
digits_pi <- c(3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5)

# Access individual entries
digits_pi[1]
digits_pi[2]
digits_pi[3]

# R is 1-indexed - a list of 11 things goes from 1 to 11
digits_pi[0]
digits_pi[11]

# Print out the vector
digits_pi
```

##### Python Vectors {-}

In python, we create vectors using the `array` function in the numpy module. To add a python module, we use the syntax `import <name> as <nickname>`. Many modules have conventional (and very short) nicknames - for `numpy`, we will use `np` as the nickname. Any functions we reference in the `numpy` module will then be called using `np.fun_name()` so that python knows where to find them.[^vectors-2]

[^vectors-2]: A similar system exists in R libraries, but R doesn't handle multiple libraries having the same function names well, which leads to all sorts of confusion. At least python is explicit about it.

```{python vector-creation-python, error = T}
import numpy as np
digits_list = [3,1,4,1,5,9,2,6,5,3,5]
digits_pi = np.array(digits_list)

# Access individual entries
digits_pi[0]
digits_pi[1]
digits_pi[2]

# Python is 0 indexed - a list of 11 things goes from 0 to 10
digits_pi[0]
digits_pi[11] 

# multiplication works on the whole vector at once
digits_pi * 2

# Print out the vector
print(digits_pi)
```


##### Python Series (Pandas)

Python has multiple things that look like vectors, including the `pandas` library's Series structure. A **Series** is a one-dimensional array-like object containing a sequence of values and an associated array of labels (called its index).


```{python series-pandas, error = T}
import pandas as pd
digits_pi = pd.Series([3,1,4,1,5,9,2,6,5,3,5])

# Access individual entries
digits_pi[0]
digits_pi[1]
digits_pi[2]

# Python is 0 indexed - a list of 11 things goes from 0 to 10
digits_pi[0]
digits_pi[11] 

# logical indexing works here too
digits_pi[digits_pi > 3]
# simple multiplication works in a vectorized manner
# that is, the whole vector is multiplied at once
digits_pi * 2

# Print out the series
print(digits_pi)
```

The Series object has a list of labels in the first printed column, and a list of values in the second. If we want, we can specify the labels manually to use as e.g. plot labels later:

```{python series-pandas2, error = T}
import pandas as pd
weekdays = pd.Series(['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], index = ['S', 'M', 'T', 'W', 'R', 'F', 'Sat'])

# access individual objs
weekdays[0]
weekdays[1]
weekdays['S']
weekdays['Sat']

# access the index
weekdays.index
weekdays.index[6] = 'Z' # you can't assign things to the index to change it

weekdays
```


:::

We can pull out items in a vector by indexing, but we can also replace specific things as well:

::: ex

::: panel-tabset

##### R {-}

```{r cat-vector-indexing}
favorite_cats <- c("Grumpy", "Garfield", "Jorts", "Jean")

favorite_cats

favorite_cats[2] <- "Nyan Cat"

favorite_cats
```

##### Python {-}

```{python cat-vector-indexing-py}
favorite_cats = ["Grumpy", "Garfield", "Jorts", "Jean"]

favorite_cats

favorite_cats[1] = "Nyan Cat"

favorite_cats
```

:::

If you're curious about any of these cats, see the footnotes[^vectors-3].

[^vectors-3]: [Grumpy cat](https://www.grumpycats.com/), [Garfield](https://www.garfield.com/), [Nyan cat](https://en.wikipedia.org/wiki/Nyan_Cat). Jorts and Jean: [The initial post](https://www.reddit.com/r/AmItheAsshole/comments/rfwgmc/aita_for_perpetuating_ethnic_stereotypes_about/) and the [update](https://www.reddit.com/user/throwawayorangecat/comments/rgi000/update_aita_for_perpetuating_stereotypes_about/) (both are worth a read because the story is hilarious). The cats also have a [Twitter account](https://twitter.com/JortsTheCat) where they promote workers rights.

:::

#### Indexing with Logical Vectors

As you might imagine, we can create vectors of all sorts of different data types. One particularly useful trick is to create a **logical vector** that goes along with a vector of another type to use as a **logical index**.

![lego vectors - a pink/purple hued set of 1x3 bricks representing the data and a corresponding set of 1x1 grey and black bricks representing the logical index vector of the same length](images/lego-logical-full.png)

If we let the black lego represent "True" and the grey lego represent "False", we can use the logical vector to pull out all values in the main vector. 

Black = True, Grey = False | Grey = True, Black = False
--- | ---
![a pink/purple hued set of 1x3 bricks representing a vector and a corresponding set of 1x1 black bricks representing the logical index vector of the same length. The grey bricks (and corresponding values of the previous vector) have been removed (filtered out).](images/lego-logical-black.png) | ![a pink/purple hued set of 1x3 bricks representing a vector and a corresponding set of 1x1 grey bricks representing the logical index vector of the same length. The black bricks (and corresponding values of the previous vector) have been removed (filtered out).](images/lego-logical-grey.png)

Note that for logical indexing to work properly, the logical index must be the same length as the vector we're indexing. This constraint will return when we talk about data frames, but for now just keep in mind that logical indexing doesn't make sense when this constraint isn't true.

::: panel-tabset

#### Indexing with logical vectors in R {-}


```{r logical-vector-indexing-r}
# Define a character vector
weekdays <- c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday")
weekend <- c("Sunday", "Saturday")

# Create logical vectors
relax_days <- c(1, 0, 0, 0, 0, 0, 1) # doing this the manual way
relax_days <- weekdays %in% weekend # This creates a logical vector 
                                    # with less manual construction
relax_days

school_days <- !relax_days # FALSE if weekend, TRUE if not
school_days

# Using logical vectors to index the character vector
weekdays[school_days] # print out all school days
```

#### Indexing with logical vectors in python {-}


```{python logical-vector-indexing-python}
import numpy as np;

animals = np.array(["Cat", "Dog", "Snake", "Lizard", "Tarantula", "Hamster", "Gerbil", "Otter"])

# Define a logical vector
good_pets = np.array([True, True, False, False, False, True, True, False])
bad_pets = np.invert(good_pets) # Invert the logical vector 
                                # so True -> False and False -> True

animals[good_pets]
animals[bad_pets]

animals[~good_pets] # equivalent to using bad_pets
```


:::

#### Reviewing Types

As vectors are a collection of things of a single type, what happens if we try to make a vector with differently-typed things?

::: panel-tabset

##### R {-}

```{r vector-type-conversion-r}
c(2L, FALSE, 3.1415, "animal") # all converted to strings

c(2L, FALSE, 3.1415) # converted to numerics

c(2L, FALSE) # converted to integers
```

##### Python {-}


```{python vector-type-conversion-python}
import numpy as np

np.array([2, False, 3.1415, "animal"]) # all converted to strings

np.array([2, False, 3.1415]) # converted to floats

np.array([2, False]) # converted to integers
```

:::


As a reminder, this is an example of **implicit** type conversion - R and python decide what type to use for you, going with the type that doesn't lose data but takes up as little space as possible.

#### Try it Out! {.unnumbered .tryitout}

::: panel-tabset

##### Problem {-}

Create a vector of the integers from one to 30. Use logical indexing to pick out only the numbers which are multiples of 3.


##### R Solution {-}

```{r}
x <- 1:30
x [ x %% 3 == 0]
```

##### Python Solution {-}

```{python}
import numpy as np
x = np.array(range(1, 31)) # because python is 0 indexed
x[ x % 3 == 0]
```

:::

::: panel-tabset

##### Challenge

Extra challenge: Pick out numbers which are multiples of 2 or 3, but not multiples of 6!

##### General Solution {-}

This operation is **xor**, a.k.a. exclusive or. That is, X or Y, but not X AND Y.

We can write xor as `(X OR Y) & !(X AND Y)` -- or we can use a predefined function: `xor()` in R, `^` in python.

##### R Solution {-}

```{r}
x <- 1:30

x2 <- x %% 2 == 0 # multiples of 2
x3 <- x %% 3 == 0 # multiples of 3
x2xor3 <- xor(x2, x3)
x2xor3_2 <- (x2 | x3) & !(x2 & x3)
x[x2xor3]
x[x2xor3_2]
```

##### Python Solution {-}

```{python}
import numpy as np
x = np.array(range(1, 31))

x2 = x % 2 == 0 # multiples of 2
x3 = x % 3 == 0 # multiples of 3
x2xor3 = x2 ^ x3

x[x2xor3]
```

:::


### Matrices

A **matrix** is the next step after a vector - it's a set of values arranged in a two-dimensional, rectangular format.

::: panel-tabset

#### Matrix (Lego) {-}

![lego depiction of a 3-row, 4-column matrix of 2x2 red-colored blocks](images/lego-2x2-matrix.png)

#### R {-}


```{r matrix-r}
# Minimal matrix in R: take a vector, 
# tell R how many rows you want
matrix(1:12, nrow = 3)

matrix(1:12, ncol = 3) # or columns

# by default, R will fill in column-by-column
# the byrow parameter tells R to go row-by-row
matrix(1:12, nrow = 3, byrow = T)

# We can also easily create square matrices 
# with a specific diagonal (this is useful for modeling)
diag(rep(1, times = 4))
```

#### Python {-}


In python, matrices are just a special case of a class called `ndarray` - n-dimensional arrays.

```{python}
import numpy as np
# Minimal ndarray in python by typing in the values in a structured format
np.array([[0,  1,  2],
          [3,  4,  5],
          [6,  7,  8],
          [9, 10, 11]])
# This syntax creates a list of the rows we want in our matrix

# Matrix in python using a data vector and size parameters
np.reshape(range(0,12), (3,4))
np.reshape(range(0,12), (4,3))
np.reshape(range(0,12), (3,4), order = 'F')
```

In python, we create 2-dimensional arrays (aka matrices) either by creating a list of rows to join together or by reshaping a 1-dimensional array. The trick with reshaping the 1-dimensional array is the order argument: 'F' stands for "Fortran-like" and 'C' stands for "C-like"... so to go by column, you use 'F' and to go by row, you use 'C'. Totally intuitive, right?


:::

This class comes before linear algebra in the required course sequence, so most of the problems we're going to work on will not require much in the way of matrix or array operations. For now, you need the following:

- Know that matrices exist and what they are (2-dimensional arrays of numbers)
- Understand how they are indexed (because it is extremely similar to data frames that we'll work with in the next chapter)
- Be aware that there are lots of functions that depend on matrix operations at their core (including linear regression)

#### Indexing in Matrices

Both R and python use \[row, column\] to index matrices. To extract the bottom-left element of a 3x4 matrix in R, we would use \[3,1\] to get to the third row and first column entry; in python, we would use \[2,0\] (remember that Python is 0-indexed).

As with vectors, you can replace elements in a matrix using assignment.

::: panel-tabset

##### R {-}

```{r}
my_mat <- matrix(1:12, nrow = 3, byrow = T)

my_mat[3,1] <- 500

my_mat
```

##### Python {-}

Remember that zero-indexing!

```{python}
import numpy as np

my_mat = np.reshape(range(1, 13), (3,4))

my_mat[2,0] = 500

my_mat
```

:::

#### Matrix Operations

There are a number of matrix operations that we need to know for basic programming purposes:

-   scalar multiplication $$c*\textbf{X} = c * \left[\begin{array}{cc} x_{1,1} & x_{1, 2}\\x_{2,1} & x_{2,2}\end{array}\right] = \left[\begin{array}{cc} c*x_{1,1} & c*x_{1, 2}\\c*x_{2,1} & c*x_{2,2}\end{array}\right]$$
-   transpose - flip the matrix across the left top -\> right bottom diagonal. $$t(\textbf{X}) = \left[\begin{array}{cc} x_{1,1} & x_{1, 2}\\x_{2,1} & x_{2,2}\end{array}\right]^T = \left[\begin{array}{cc} x_{1,1} & x_{2,1}\\x_{1,2} & x_{2,2}\end{array}\right]$$
-   matrix multiplication (dot product) - you will learn more about this in linear algebra, but here's a preview. [Here is a better explanation of the cross product](https://www.mathsisfun.com/algebra/matrix-multiplying.html) $$\textbf{X}*\textbf{Y} = \left[\begin{array}{cc} x_{1,1} & x_{1, 2}\\x_{2,1} & x_{2,2}\end{array}\right] * \left[\begin{array}{cc} y_{1,1} \\y_{2,1} \end{array}\right] = \left[\begin{array}{c}x_{1,1}*y_{1,1} + x_{1,2}*y_{2,1} \\x_{2, 1}*y_{1,1} + x_{2,2}*y_{2,1}\end{array}\right]$$ Note that matrix multiplication depends on having matrices of compatible dimensions. If you have two matrices of dimension $(a \times b)$ and $(c \times d)$, then $b$ must be equal to $c$ for the multiplication to work, and your result will be $(a \times d)$.

::: panel-tabset

##### R {-}

```{r, results = 'show'}
x <- matrix(c(1, 2, 3, 4), nrow = 2, byrow = T)
y <- matrix(c(5, 6), nrow = 2)

# Scalar multiplication
x * 3
3 * x

# Transpose
t(x)
t(y)

# matrix multiplication (dot product)
x %*% y
```

##### Python {-}

```{python}
import numpy as np
x = np.array([[1,2],[3,4]])
y = np.array([[5],[6]])

# scalar multiplication
x*3
3*x

# transpose
x.T # shorthand
x.transpose() # Long form

# Matrix multiplication (dot product)
np.dot(x, y)
```

:::

### Arrays

Arrays are a generalized n-dimensional version of a vector: all elements have the same type, and they are indexed using square brackets in both R and python: `[dim1, dim2, dim3, ...]`

I don't think you will need to create 3+ dimensional arrays in this class, but if you want to try it out, here is some code.

::: panel-tabset

#### R {-}

```{r}
array(1:8, dim = c(2,2,2))
```

Note that displaying this requires 2 slices, since it's hard to display 3D information in a 2D terminal arrangement.

#### Python {-}

```{python}
import numpy as np

np.array([[[1,2],[3,4]],[[5,6], [7,8]]])
```

:::

## Control Structures

Control structures are statements in a program that determine when code is evaluated (and how many times it might be evaluated). There are two main types of control structures: if-statements and loops.

Before we start on the types of control structures, let's get in the right mindset. We're all used to "if-then" logic, and use it in everyday conversation, but computers require another level of specificity when you're trying to provide instructions.

Check out this video of the classic "make a peanut butter sandwich instructions challenge":

<iframe width="773" height="435" src="https://www.youtube.com/embed/Ct-lOOUqmyY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>

</iframe>

Here's another example:

!['If you're done being pedantic, we should get dinner.' 'You did it again!' 'No, I didn't.'](https://imgs.xkcd.com/comics/conditionals.png)

The key takeaways from these bits of media are that you should read this section with a focus on exact precision - state *exactly* what you mean, and the computer will do what you say. If you instead expect the computer to get what you mean, you're going to have a bad time.

### Conditional Statements

Conditional statements determine if code is evaluated.

They look like this:

    if (condition)
      then
        (thing to do)
      else
        (other thing to do)

The else (other thing to do) part may be omitted.

When this statement is read by the computer, the computer checks to see if condition is true or false. If the condition is true, then (thing to do) is also run. If the condition is false, then (other thing to do) is run instead.

Let's try this out:

::: panel-tabset

#### R {-}

```{r}
x <- 3
y <- 1

if (x > 2) { 
  y <- 8
} else {
  y <- 4
}

print(paste("x =", x, "; y =", y))
```

In R, the logical condition after `if` must be in parentheses. It is common to then enclose the statement to be run if the condition is true in `{}` so that it is clear what code matches the if statement. You can technically put the condition on the line after the `if (x > 2)` line, and everything will still work, but then it gets hard to figure out what to do with the else statement - it technically would also go on the same line, and that gets hard to read.

```{r}
x <- 3
y <- 1

if (x > 2) y <- 8 else y <- 4

print(paste("x =", x, "; y =", y))
```

So while the 2nd version of the code technically works, the first version with the brackets is much easier to read and understand. Please try to emulate the first version!

#### Python {-}

```{python}
x = 3
y = 1

if x > 2:
  y = 8
else:
  y = 4

print("x =", x, "; y =", y)
```

In python, all code grouping is accomplished with spaces instead of with brackets. So in python, we write our if statement as `if x > 2:` with the colon indicating that what follows is the code to evaluate. The next line is indented with 2 spaces to show that the code on those lines belongs to that if statement. Then, we use the else: statement to provide an alternative set of code to run if the logical condition in the if statement is false. Again, we indent the code under the else statement to show where it "belongs".

Python will throw errors if you mess up the spacing. This is one thing that is very annoying about Python... but it's a consequence of trying to make the code more readable.

<!-- https://www.py4e.com/html3/03-conditional -->

:::


#### Representing Conditional Statements as Diagrams

A common way to represent conditional logic is to draw a flow chart diagram.

In a flow chart, conditional statements are represented as diamonds, and other code is represented as a rectangle. Yes/no or True/False branches are labeled. Typically, after a conditional statement, the program flow returns to a single point.

![Program flow diagram outline of a simple if/else statement](images/flow-chart1.png)

#### Try it out! {- .tryitout}

::: panel-tabset

##### Problem {-}

The US Tax code has brackets, such that the first \$10,275 of your income is taxed at 10%, anything between \$10,275 and \$41,775 is taxed at 12%, and so on.

Here is the table of tax brackets for single filers in 2022:

| rate | Income                 |
|------|------------------------|
| 10%  | \$0 to \$10,275        |
| 12%  | \$10,275 to \$41,775   |
| 22%  | \$41,775 to \$89,075   |
| 24%  | \$89,075 to \$170,050  |
| 32%  | \$170,050 to \$215,950 |
| 35%  | \$215,950 to \$539,900 |
| 37%  | \$539,900 or more      |

Note: For the purposes of this problem, we're ignoring the personal exemption and the standard deduction, so we're already simplifying the tax code.

Write a set of if statements that assess someone's income and determine what their overall tax rate is.

Hint: You may want to keep track of how much of the income has already been taxed in a variable and what the total tax accumulation is in another variable.

##### R Solution {-}

```{r}
# Start with total income
income <- 200000

# x will hold income that hasn't been taxed yet
x <- income
# y will hold taxes paid
y <- 0

if (x <= 10275) {
  y <- x*.1 # tax paid
  x <- 0 # All money has been taxed
} else {
  y <- y + 10275 * .1
  x <- x - 10275 # Money remaining that hasn't been taxed
}

if (x <= (41775 - 10275)) {
  y <- y + x * .12
  x <- 0
} else {
  y <- y + (41775 - 10275) * .12
  x <- x - (41775 - 10275) 
}

if (x <= (89075 - 41775)) {
  y <- y + x * .22
  x <- 0
} else {
  y <- y + (89075 - 41775) * .22
  x <- x - (89075 - 41775)
}

if (x <= (170050 - 89075)) {
  y <- y + x * .24
  x <- 0
} else {
  y <- y + (170050 - 89075) * .24
  x <- x - (170050 - 89075)
}

if (x <= (215950 - 170050)) {
  y <- y + x * .32
  x <- 0
} else {
  y <- y + (215950 - 170050) * .32
  x <- x - (215950 - 170050)
}

if (x <= (539900 - 215950)) {
  y <- y + x * .35
  x <- 0
} else {
  y <- y + (539900 - 215950) * .35
  x <- x - (539900 - 215950)
}

if (x > 0) {
  y <- y + x * .37
}


print(paste("Total Tax Rate on $", income, " in income = ", round(y/income, 4)*100, "%"))
```

##### Python Solution {-}


```{python}
# Start with total income
income = 200000

# untaxed will hold income that hasn't been taxed yet
untaxed = income
# taxed will hold taxes paid
taxes = 0

if untaxed <= 10275:
  taxes = untaxed*.1 # tax paid
  untaxed = 0 # All money has been taxed
else:
  taxes = taxes + 10275 * .1
  untaxed = untaxed - 10275 # money remaining that hasn't been taxed

if untaxed <= (41775 - 10275):
  taxes = taxes + untaxed * .12
  untaxed = 0
else:
  taxes = taxes + (41775 - 10275) * .12
  untaxed = untaxed - (41775 - 10275) 


if untaxed <= (89075 - 41775):
  taxes = taxes + untaxed * .22
  untaxed = 0
else: 
  taxes = taxes + (89075 - 41775) * .22
  untaxed = untaxed - (89075 - 41775)

if untaxed <= (170050 - 89075):
  taxes = taxes + untaxed * .24
  untaxed = 0
else: 
  taxes = taxes + (170050 - 89075) * .24
  untaxed = untaxed - (170050 - 89075)

if untaxed <= (215950 - 170050):
  taxes = taxes + untaxed * .32
  untaxed = 0
else:
  taxes = taxes + (215950 - 170050) * .32
  untaxed = untaxed - (215950 - 170050)

if untaxed <= (539900 - 215950):
  taxes = taxes + untaxed * .35
  untaxed = 0
else: 
  taxes = taxes + (539900 - 215950) * .35
  untaxed = untaxed - (539900 - 215950)


if untaxed > 0:
  taxes = taxes + untaxed * .37



print("Total Tauntaxed Rate on $", income, " in income = ", round(taxes/income, 4)*100, "%")
```

We will find a better way to represent this calculation once we discuss loops - we can store each bracket's start and end point in a vector and loop through them. Any time you find yourself copy-pasting code and changing values, you should consider using a loop (or eventually a function) instead.


##### Program Flow Chart

Let's explore using program flow maps for a slightly more complicated problem: The tax bracket example that we used to demonstrate if statement syntax.

<!-- First, let's start by looking at a graph of the practical implication of taxing things using brackets. This graph shows the amount in each bracket as well as the amount of taxes paid. -->

```{r tax-data, echo = F, eval = F, fig.width = 5, fig.height = 4, out.width = "60%", fig.cap = "Marginal tax brackets for an income of \\$200k"}
library(tidyverse)

df <- tribble(
~rate, ~LB, ~UB,
.1, 0, 10275	,
.12, 10275, 41775,
.22, 41775, 89075,
.24, 89075, 170050,
.32, 170050, 215950,
.35, 215950, 539900,
.37, 539900, Inf
)  %>% 
  mutate(bracket = 1:n()) %>%
  mutate(bracket_lab = factor(bracket, labels = sprintf("~%0.0fK - ~%0.0fK", LB/1000, UB/1000) %>% str_remove(" - ~InfK") %>% str_replace("~0K", "0"))) %>%
  mutate(
  taxable_amount = pmax(pmin((x - LB),0), pmax(0,pmin(UB, x) - LB)),
  taxes = taxable_amount * rate,
  untaxed_amount = taxable_amount - taxes
)

x <- 200000

df2 <- df %>%
  pivot_longer(taxable_amount:taxes, names_to = "type", values_to = "amount") %>%
  mutate(type = str_replace_all(type, c("taxes" = "Taxes", "taxable_amount" = "Taxable Amount")))

df2 %>% 
  ggplot(aes(ymin = bracket -.4, ymax = bracket + .4, xmin = 0, xmax = amount, fill = type)) + 
  geom_rect(alpha = .5, color = "black") +
  scale_fill_manual(values = c("Taxes" = "black", "Taxable Amount" = "white")) + 
  scale_y_continuous("Tax Bracket", breaks = df$bracket, labels = df$bracket_lab) + 
  scale_x_continuous("Marginal Amount", expand = expansion(mult = c(0.025, .1), add = c(0, .1))) + 
  geom_text(data = filter(df2, df2$type == "Taxable Amount"), aes(x = amount, y = bracket, label = sprintf("%.0f%%", rate*100), color = "Marginal rate"), hjust = -.1) + 
  scale_color_manual("", values = c("Marginal rate" = "red")) + 
  theme_bw() + 
  theme(legend.position = "bottom", legend.title = element_blank()) + 
  ggtitle("Breaking down Taxation (Single Bracket, 2022, for 200K)")

```

![The control flow diagram for the code in the previous example](images/tax-brackets.png)


Control flow diagrams can be extremely helpful when figuring out how programs work (and where gaps in your logic are when you're debugging). It can be very helpful to map out your program flow as you're untangling a problem.

:::

#### Chaining Conditional Statements: Else-If

In many cases, it can be helpful to have a long chain of conditional statements describing a sequence of alternative statements.

::: ex

For instance, suppose I want to determine what categorical age bracket someone falls into based on their numerical age. All of the bins are mutually exclusive - you can't be in the 25-40 bracket and the 41-55 bracket.

::: panel-tabset

##### Program Flow Map {-}

![Program flow map for a series of mutually exclusive categories. If our goal is to take a numeric age variable and create a categorical set of age brackets, such as \<18, 18-25, 26-40, 41-55, 56-65, and \>65, we can do this with a series of if-else statements chained together. Only one of the bracket assignments is evaluated, so it is important to place the most restrictive condition first.](images/age-category-prog-flow.png)

The important thing to realize when examining this program flow map is that if `age <= 18` is true, then **none of the other conditional statements even get evaluated**. That is, once a statement is true, none of the other statements matter. Because of this, it is important to place the most restrictive statement first.

![Program flow map for a series of mutually exclusive categories, emphasizing that only some statements are evaluated. When age = 40, only (age \<= 18), (age \<= 25), and (age \<= 40) are evaluated conditionally. Of the assignment statements, only bracket = '26-40' is evaluated when age = 40.](images/age-category-prog-flow2.png)

If for some reason you wrote your conditional statements in the wrong order, the wrong label would get assigned:

![Program flow map for a series of mutually exclusive categories, with category labels in the wrong order - \<40 is evaluated first, and so \<= 25 and \<= 18 will never be evaluated and the wrong label will be assigned for anything in those categories.](images/age-category-prog-flow3.png)


In code, we would write this statement using `else-if` (or `elif`) statements.

##### R {-}

```{r else-if-statements}
age <- 40 # change this as you will to see how the code works

if (age < 18) {
  bracket <- "<18"
} else if (age <= 25) {
  bracket <- "18-25"
} else if (age <= 40) {
  bracket <- "26-40"
} else if (age <= 55) {
  bracket <- "41-55" 
} else if (age <= 65) {
  bracket <- "56-65"
} else {
  bracket <- ">65"
}

bracket
```

##### Python {-}

Python uses `elif` as a shorthand for `else if` statements. As always, indentation/white space in python matters. If you put an extra blank line between two elif statements, then the interpreter will complain. If you don't indent properly, the interpreter will complain.


```{python elif-statements}
age = 40 # change this to see how the code works

if age < 18:
  bracket = "<18"
elif age <= 25:
  bracket = "18-25"
elif age <= 40:
  bracket = "26-40"
elif age <= 55:
  bracket = "41-55"
elif age <= 65:
  bracket = "56-65"
else:
  bracket = ">65"
  
bracket
```

:::

:::

### Loops

<!-- https://www.py4e.com/html3/05-iterations -->

Often, we write programs which update a variable in a way that the new value of the variable depends on the old value:

    x = x + 1

This means that we add one to the current value of `x`.

Before we write a statement like this, we have to **initialize** the value of `x` because otherwise, we don't know what value to add one to.

    x = 0
    x = x + 1

We sometimes use the word **increment** to talk about adding one to the value of `x`; **decrement** means subtracting one from the value of `x`.

A particularly powerful tool for making these types of repetitive changes in programming is the **loop**, which executes statements a certain number of times. Loops can be written in several different ways, but all loops allow for executing a block of code a variable number of times.

#### While Loops

In the previous section, we discussed conditional statements, where a block of code is only executed *if* a logical statement is true.

The simplest type of loop is the **while** loop, which executes a block of code until a statement is no longer true.

![Flow map showing while-loop pseudocode (while x \<= N) { \# code that changes x in some way} and the program flow map expansion where we check if x \> N (exiting the loop if true); otherwise, we continue into the loop, execute the main body of #code and then change x and start over.](images/while-loop-flow.png)

::: panel-tabset

##### R {-}

```{r while-loop-r}
x <- 0

while (x < 10) { 
  # Everything in here is executed 
  # during each iteration of the loop
  print(x)
  x <- x + 1
}
```

##### Python {-}


```{python while-loop-py}
x = 0

while x < 10:
  print(x)
  x = x + 1

```

:::

#### Try it Out! {.unnumbered .tryitout}

::: panel-tabset

##### Problem {-}

Write a while loop that verifies that $$\lim_{N \rightarrow \infty} \prod_{k=1}^N \left(1 + \frac{1}{k^2}\right) = \frac{e^\pi - e^{-\pi}}{2\pi}.$$

Terminate your loop when you get within 0.0001 of $\frac{e^\pi - e^{-\pi}}{2\pi}$. At what value of $k$ is this point reached?

##### Math Notation {-}

Breaking down math notation for code:

-   If you are unfamiliar with the notation $\prod_{k=1}^N f(k)$, this is the product of $f(k)$ for $k = 1, 2, ..., N$, $$f(1)\cdot f(2)\cdot ... \cdot f(N)$$

-   To evaluate a limit, we just keep increasing $N$ until we get arbitrarily close to the right hand side of the equation.

In this problem, we can just keep increasing $k$ and keep track of the cumulative product. So we define `k=1`, `prod = 1`, and `ans` before the loop starts. Then, we loop over `k`, multiplying `prod` by $(1 + 1/k^2)$ and then incrementing $k$ by one each time. At each iteration, we test whether `prod` is close enough to `ans` to stop the loop.

##### R Solution {-}

In R, you will use `pi` and `exp()` - these are available by default without any additional libraries or packages.


```{r}
k <- 1
prod <- 1
ans <- (exp(pi) - exp(-pi))/(2*pi)
delta <- 0.0001

while (abs(prod - ans) >= 0.0001) {
  prod <- prod * (1 + 1/k^2)
  k <- k + 1
}

k
prod
ans
```

##### Python solution {-}

Note that in python, you will have to import the math library to get the values of pi and the `exp` function. You can refer to these as `math.pi` and `math.exp()` respectively.

```{python}
import math

k = 1
prod = 1
ans = (math.exp(math.pi) - math.exp(-math.pi))/(2*math.pi)
delta = 0.0001

while abs(prod - ans) >= 0.0001:
  prod = prod * (1 + k**-2)
  k = k + 1
  if k > 500000:
    break


print("At ", k, " iterations, the product is ", prod, "compared to the limit ", ans,".")
```


:::

#### For Loops

Another common type of loop is a **for** loop. In a for loop, we run the block of code, iterating through a series of values (commonly, one to N, but not always). Generally speaking, for loops are known as **definite** loops because the code inside a for loop is executed a specific number of times. While loops are known as **indefinite** loops because the code within a while loop is evaluated until the condition is falsified, which is not always a known number of times.


::: panel-tabset

##### Flow Map {-}

![Flow map showing for-loop pseudocode (for j in 1 to N) { \# code} and the program flow map expansion where j starts at 1 and we check if j \> N (exiting the loop if true); otherwise, we continue into the loop, execute the main body of #code and then increment j and start over.](images/for-loop-flow.png)

##### R {-}

```{r}
for (i in 1:5 ) {
  print(i)
}

```

##### Python {-}

```{python}
for i in range(5):
  print(i)

```

By default `range`(5) goes from 0 to 5, the upper bound. When `i = 5` the loop exits. This is because `range(5)` creates a vector `[0, 1, 2, 3, 4]`.

:::

For loops are often run from 1 to N (or 0 to N-1 in python) but in essence, a for loop is run for every value of a vector (which is why loops are included in the same chapter as vectors).

::: ex

::: panel-tabset

##### R {-}

For instance, in R, there is a built-in variable called `month.name`. Type `month.name` into your R console to see what it looks like. If we want to iterate along the values of month.name, we can:

```{r}
for (i in month.name)
  print(i)
```

##### Python {-}

In python, we have to define our vector or list to start out with, but that's easy enough:

```{python}
futurama_crew = ['Fry', 'Leela', 'Bender', 'Amy', 'the Professor', 'Hermes', 'Zoidberg', 'Nibbler']
for i in futurama_crew:
  print(i)

```

:::

:::

::: watch-out

#### Avoiding Infinite Loops

It is very easy to create an **infinite** loop when you are working with while loops. Infinite loops never exit, because the condition is always true. If in the while loop example we decrement x instead of incrementing x, the loop will run forever.

You want to try very hard to avoid ever creating an infinite loop - it can cause your session to crash.

One common way to avoid infinite loops is to create a second variable that just counts how many times the loop has run. If that variable gets over a certain threshold, you exit the loop.

::: panel-tabset

##### R {-}

This while loop runs until either x \< 10 or n \> 50 - so it will run an indeterminate number of times and depends on the random values added to x. Since this process (a 'random walk') could theoretically continue forever, we add the n\>50 check to the loop so that we don't tie up the computer for eternity.

```{r infinite-loop-exit-r}
x <- 0
n <- 0 # count the number of times the loop runs

while (x < 10) { 
  print(x)
  x <- x + rnorm(1) # add a random normal (0, 1) draw each time
  n <- n + 1
  if (n > 50) 
    break # this stops the loop if n > 50
}
```

##### Python {-}

```{python infinite-loop-exit-py}
import numpy as np; # for the random normal draw

x = 0
n = 0 # count the number of times the loop runs

while x < 10:
  print(x)
  x = x + np.random.normal(0, 1, 1) # add a random normal (0, 1) draw each time
  n = n + 1
  if n > 50:
    break # this stops the loop if n > 50

```

:::

In both of the examples above, there are more efficient ways to write a random walk, but we will get to that later. The important thing here is that we want to make sure that our loops don't run for all eternity.

:::

#### Controlling Loops

<!-- https://www.py4e.com/html3/05-iterations -->

<!-- https://www.datamentor.io/r-programming/break-next/ -->

Sometimes it is useful to control the statements in a loop with a bit more precision. You may want to skip over code and proceed directly to the next iteration, or, as demonstrated in the previous section with the `break` statement, it may be useful to exit the loop prematurely.

::: panel-tabset

##### Break Statement {-}

![A break statement is used to exit a loop prematurely](images/break-statement.png)

##### Next/Continue Statement {-}

![A next (or continue) statement is used to skip the body of the loop and continue to the next iteration](images/next-statement-flow.png)

:::

::: ex

Let's demonstrate the details of next/continue and break statements.

We can do different things based on whether i is evenly divisible by 3, 5, or both 3 and 5 (thus divisible by 15)

::: panel-tabset

##### R {-}


```{r}
for (i in 1:20) {
  if (i %% 15 == 0) {
    print("Exiting now")
    break
  } else if (i %% 3 == 0) {    
    print("Divisible by 3")
    next
    print("After the next statement") # this should never execute
  } else if (i %% 5 == 0) {
    print("Divisible by 5")
  } else {
    print(i)
  }
}
```

##### Python {-}

```{python}
for i in range(1, 20):
  if i%15 == 0:
    print("Exiting now")
    break
  elif i%3 == 0:
    print("Divisible by 3")
    continue
    print("After the next statement") # this should never execute
  elif i%5 == 0:
    print("Divisible by 5")
  else: 
    print(i)

```

:::

:::

To be quite honest, I haven't really ever needed to use next/continue statements when I'm programming, and I rarely use break statements. However, it's useful to know they exist just in case you come across a problem where you could put either one to use.
